Project Path: src

Source Tree:

```
src
├── base.ts
├── interactions.ts
├── search.ts
├── plugins
│   ├── templates.ts
│   └── SttTtsSpacesPlugin.ts
├── environment.ts
├── utils.ts
├── types.ts
├── spaces.ts
├── __tests__
│   └── environment.test.ts
├── client.ts
├── index.ts
└── post.ts

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/base.ts`:

```ts
import {
    type Content,
    type IAgentRuntime,
    type IImageDescriptionService,
    type Memory,
    type State,
    type UUID,
    getEmbeddingZeroVector,
    elizaLogger,
    stringToUuid,
    ActionTimelineType,
} from "@elizaos/core";
import {
    type QueryTweetsResponse,
    Scraper,
    SearchMode,
    type Tweet,
} from "agent-twitter-client";
import { EventEmitter } from "events";
import type { TwitterConfig } from "./environment.ts";

export function extractAnswer(text: string): string {
    const startIndex = text.indexOf("Answer: ") + 8;
    const endIndex = text.indexOf("<|eof|>", 11);
    return text.slice(startIndex, endIndex);
}

type TwitterProfile = {
    id: string;
    username: string;
    screenName: string;
    bio: string;
    nicknames: string[];
};

class RequestQueue {
    private queue: (() => Promise<any>)[] = [];
    private processing = false;

    async add<T>(request: () => Promise<T>): Promise<T> {
        return new Promise((resolve, reject) => {
            this.queue.push(async () => {
                try {
                    const result = await request();
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            });
            this.processQueue();
        });
    }

    private async processQueue(): Promise<void> {
        if (this.processing || this.queue.length === 0) {
            return;
        }
        this.processing = true;

        while (this.queue.length > 0) {
            const request = this.queue.shift()!;
            try {
                await request();
            } catch (error) {
                console.error("Error processing request:", error);
                this.queue.unshift(request);
                await this.exponentialBackoff(this.queue.length);
            }
            await this.randomDelay();
        }

        this.processing = false;
    }

    private async exponentialBackoff(retryCount: number): Promise<void> {
        const delay = Math.pow(2, retryCount) * 1000;
        await new Promise((resolve) => setTimeout(resolve, delay));
    }

    private async randomDelay(): Promise<void> {
        const delay = Math.floor(Math.random() * 2000) + 1500;
        await new Promise((resolve) => setTimeout(resolve, delay));
    }
}

export class ClientBase extends EventEmitter {
    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};
    twitterClient: Scraper;
    runtime: IAgentRuntime;
    twitterConfig: TwitterConfig;
    directions: string;
    lastCheckedTweetId: bigint | null = null;
    imageDescriptionService: IImageDescriptionService;
    temperature = 0.5;

    requestQueue: RequestQueue = new RequestQueue();

    profile: TwitterProfile | null;

    async cacheTweet(tweet: Tweet): Promise<void> {
        if (!tweet) {
            console.warn("Tweet is undefined, skipping cache");
            return;
        }

        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);
    }

    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {
        const cached = await this.runtime.cacheManager.get<Tweet>(
            `twitter/tweets/${tweetId}`
        );

        return cached;
    }

    async getTweet(tweetId: string): Promise<Tweet> {
        const cachedTweet = await this.getCachedTweet(tweetId);

        if (cachedTweet) {
            return cachedTweet;
        }

        const tweet = await this.requestQueue.add(() =>
            this.twitterClient.getTweet(tweetId)
        );

        await this.cacheTweet(tweet);
        return tweet;
    }

    callback: (self: ClientBase) => any = null;

    onReady() {
        throw new Error(
            "Not implemented in base class, please call from subclass"
        );
    }

    /**
     * Parse the raw tweet data into a standardized Tweet object.
     */
    private parseTweet(raw: any, depth = 0, maxDepth = 3): Tweet {
        // If we've reached maxDepth, don't parse nested quotes/retweets further
        const canRecurse = depth < maxDepth;

        const quotedStatus = raw.quoted_status_result?.result && canRecurse
            ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)
            : undefined;

        const retweetedStatus = raw.retweeted_status_result?.result && canRecurse
            ? this.parseTweet(raw.retweeted_status_result.result, depth + 1, maxDepth)
            : undefined;

        const t: Tweet = {
            bookmarkCount:
                raw.bookmarkCount ?? raw.legacy?.bookmark_count ?? undefined,
            conversationId:
                raw.conversationId ?? raw.legacy?.conversation_id_str,
            hashtags: raw.hashtags ?? raw.legacy?.entities?.hashtags ?? [],
            html: raw.html,
            id: raw.id ?? raw.rest_id ?? raw.id_str ?? undefined,
            inReplyToStatus: raw.inReplyToStatus,
            inReplyToStatusId:
                raw.inReplyToStatusId ??
                raw.legacy?.in_reply_to_status_id_str ??
                undefined,
            isQuoted: raw.legacy?.is_quote_status === true,
            isPin: raw.isPin,
            isReply: raw.isReply,
            isRetweet: raw.legacy?.retweeted === true,
            isSelfThread: raw.isSelfThread,
            language: raw.legacy?.lang,
            likes: raw.legacy?.favorite_count ?? 0,
            name:
                raw.name ??
                raw?.user_results?.result?.legacy?.name ??
                raw.core?.user_results?.result?.legacy?.name,
            mentions: raw.mentions ?? raw.legacy?.entities?.user_mentions ?? [],
            permanentUrl:
                raw.permanentUrl ??
                (raw.core?.user_results?.result?.legacy?.screen_name &&
                 raw.rest_id
                    ? `https://x.com/${raw.core?.user_results?.result?.legacy?.screen_name}/status/${raw.rest_id}`
                    : undefined),
            photos:
                raw.photos ??
                (raw.legacy?.entities?.media
                    ?.filter((media: any) => media.type === "photo")
                    .map((media: any) => ({
                        id: media.id_str,
                        url: media.media_url_https,
                        alt_text: media.alt_text,
                    })) || []),
            place: raw.place,
            poll: raw.poll ?? null,
            quotedStatus,
            quotedStatusId:
                raw.quotedStatusId ?? raw.legacy?.quoted_status_id_str ?? undefined,
            quotes: raw.legacy?.quote_count ?? 0,
            replies: raw.legacy?.reply_count ?? 0,
            retweets: raw.legacy?.retweet_count ?? 0,
            retweetedStatus,
            retweetedStatusId: raw.legacy?.retweeted_status_id_str ?? undefined,
            text: raw.text ?? raw.legacy?.full_text ?? undefined,
            thread: raw.thread || [],
            timeParsed: raw.timeParsed
                ? new Date(raw.timeParsed)
                : raw.legacy?.created_at
                ? new Date(raw.legacy?.created_at)
                : undefined,
            timestamp:
                raw.timestamp ??
                (raw.legacy?.created_at
                    ? new Date(raw.legacy.created_at).getTime() / 1000
                    : undefined),
            urls: raw.urls ?? raw.legacy?.entities?.urls ?? [],
            userId: raw.userId ?? raw.legacy?.user_id_str ?? undefined,
            username:
                raw.username ??
                raw.core?.user_results?.result?.legacy?.screen_name ??
                undefined,
            videos:
                raw.videos ??
                (raw.legacy?.entities?.media
                    ?.filter((media: any) => media.type === "video") ?? []),
            views: raw.views?.count ? Number(raw.views.count) : 0,
            sensitiveContent: raw.sensitiveContent,
        };

        return t;
    }

    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {
        super();
        this.runtime = runtime;
        this.twitterConfig = twitterConfig;
        const username = twitterConfig.TWITTER_USERNAME;
        if (ClientBase._twitterClients[username]) {
            this.twitterClient = ClientBase._twitterClients[username];
        } else {
            this.twitterClient = new Scraper();
            ClientBase._twitterClients[username] = this.twitterClient;
        }

        this.directions =
            "- " +
            this.runtime.character.style.all.join("\n- ") +
            "- " +
            this.runtime.character.style.post.join();
    }

    async init() {
        const username = this.twitterConfig.TWITTER_USERNAME;
        const password = this.twitterConfig.TWITTER_PASSWORD;
        const email = this.twitterConfig.TWITTER_EMAIL;
        let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;
        const twitter2faSecret = this.twitterConfig.TWITTER_2FA_SECRET;

        if (!username) {
            throw new Error("Twitter username not configured");
        }

        const authToken = this.runtime.getSetting("TWITTER_COOKIES_AUTH_TOKEN");
        const ct0 = this.runtime.getSetting("TWITTER_COOKIES_CT0");
        const guestId = this.runtime.getSetting("TWITTER_COOKIES_GUEST_ID");

        const createTwitterCookies = (authToken: string, ct0: string, guestId: string) => 
        authToken && ct0 && guestId
            ? [
                { key: 'auth_token', value: authToken, domain: '.twitter.com' },
                { key: 'ct0', value: ct0, domain: '.twitter.com' },
                { key: 'guest_id', value: guestId, domain: '.twitter.com' },
            ]
            : null;

        const cachedCookies = await this.getCachedCookies(username) || createTwitterCookies(authToken, ct0, guestId);

        if (cachedCookies) {
            elizaLogger.info("Using cached cookies");
            await this.setCookiesFromArray(cachedCookies);
        }

        elizaLogger.log("Waiting for Twitter login");
        while (retries > 0) {
            try {
                if (await this.twitterClient.isLoggedIn()) {
                    // cookies are valid, no login required
                    elizaLogger.info("Successfully logged in.");
                    break;
                } else {
                    await this.twitterClient.login(
                        username,
                        password,
                        email,
                        twitter2faSecret
                    );
                    if (await this.twitterClient.isLoggedIn()) {
                        // fresh login, store new cookies
                        elizaLogger.info("Successfully logged in.");
                        elizaLogger.info("Caching cookies");
                        await this.cacheCookies(
                            username,
                            await this.twitterClient.getCookies()
                        );
                        break;
                    }
                }
            } catch (error) {
                elizaLogger.error(`Login attempt failed: ${error.message}`);
            }

            retries--;
            elizaLogger.error(
                `Failed to login to Twitter. Retrying... (${retries} attempts left)`
            );

            if (retries === 0) {
                elizaLogger.error(
                    "Max retries reached. Exiting login process."
                );
                throw new Error("Twitter login failed after maximum retries.");
            }

            await new Promise((resolve) => setTimeout(resolve, 2000));
        }
        // Initialize Twitter profile
        this.profile = await this.fetchProfile(username);

        if (this.profile) {
            elizaLogger.log("Twitter user ID:", this.profile.id);
            elizaLogger.log(
                "Twitter loaded:",
                JSON.stringify(this.profile, null, 10)
            );
            // Store profile info for use in responses
            this.runtime.character.twitterProfile = {
                id: this.profile.id,
                username: this.profile.username,
                screenName: this.profile.screenName,
                bio: this.profile.bio,
                nicknames: this.profile.nicknames,
            };
        } else {
            throw new Error("Failed to load profile");
        }

        await this.loadLatestCheckedTweetId();
        await this.populateTimeline();
    }

    async fetchOwnPosts(count: number): Promise<Tweet[]> {
        elizaLogger.debug("fetching own posts");
        const homeTimeline = await this.twitterClient.getUserTweets(
            this.profile.id,
            count
        );
        // Use parseTweet on each tweet
        return homeTimeline.tweets.map((t) => this.parseTweet(t));
    }

    /**
     * Fetch timeline for twitter account, optionally only from followed accounts
     */
    async fetchHomeTimeline(
        count: number,
        following?: boolean
    ): Promise<Tweet[]> {
        elizaLogger.debug("fetching home timeline");
        const homeTimeline = following
            ? await this.twitterClient.fetchFollowingTimeline(count, [])
            : await this.twitterClient.fetchHomeTimeline(count, []);

        elizaLogger.debug(homeTimeline, { depth: Number.POSITIVE_INFINITY });
        const processedTimeline = homeTimeline
            .filter((t) => t.__typename !== "TweetWithVisibilityResults") // what's this about?
            .map((tweet) => this.parseTweet(tweet));

        //elizaLogger.debug("process homeTimeline", processedTimeline);
        return processedTimeline;
    }

    async fetchTimelineForActions(count: number): Promise<Tweet[]> {
        elizaLogger.debug("fetching timeline for actions");

        const agentUsername = this.twitterConfig.TWITTER_USERNAME;

        const homeTimeline =
            this.twitterConfig.ACTION_TIMELINE_TYPE ===
            ActionTimelineType.Following
                ? await this.twitterClient.fetchFollowingTimeline(count, [])
                : await this.twitterClient.fetchHomeTimeline(count, []);

        // Parse, filter out self-tweets, limit to count
        return homeTimeline
            .map((tweet) => this.parseTweet(tweet))
            .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets
            .slice(0, count);
        // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',
        // this workaround can be removed.
        // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43
    }

    async fetchSearchTweets(
        query: string,
        maxTweets: number,
        searchMode: SearchMode,
        cursor?: string
    ): Promise<QueryTweetsResponse> {
        try {
            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array
            // if we dont get a response in 5 seconds, something is wrong
            const timeoutPromise = new Promise((resolve) =>
                setTimeout(() => resolve({ tweets: [] }), 15000)
            );

            try {
                const result = await this.requestQueue.add(
                    async () =>
                        await Promise.race([
                            this.twitterClient.fetchSearchTweets(
                                query,
                                maxTweets,
                                searchMode,
                                cursor
                            ),
                            timeoutPromise,
                        ])
                );
                return (result ?? { tweets: [] }) as QueryTweetsResponse;
            } catch (error) {
                elizaLogger.error("Error fetching search tweets:", error);
                return { tweets: [] };
            }
        } catch (error) {
            elizaLogger.error("Error fetching search tweets:", error);
            return { tweets: [] };
        }
    }

    private async populateTimeline() {
        elizaLogger.debug("populating timeline...");

        const cachedTimeline = await this.getCachedTimeline();

        // Check if the cache file exists
        if (cachedTimeline) {
            // Read the cached search results from the file

            // Get the existing memories from the database
            const existingMemories =
                await this.runtime.messageManager.getMemoriesByRoomIds({
                    roomIds: cachedTimeline.map((tweet) =>
                        stringToUuid(
                            tweet.conversationId + "-" + this.runtime.agentId
                        )
                    ),
                });

            //TODO: load tweets not in cache?

            // Create a Set to store the IDs of existing memories
            const existingMemoryIds = new Set(
                existingMemories.map((memory) => memory.id.toString())
            );

            // Check if any of the cached tweets exist in the existing memories
            const someCachedTweetsExist = cachedTimeline.some((tweet) =>
                existingMemoryIds.has(
                    stringToUuid(tweet.id + "-" + this.runtime.agentId)
                )
            );

            if (someCachedTweetsExist) {
                // Filter out the cached tweets that already exist in the database
                const tweetsToSave = cachedTimeline.filter(
                    (tweet) =>
                        !existingMemoryIds.has(
                            stringToUuid(tweet.id + "-" + this.runtime.agentId)
                        )
                );

                console.log({
                    processingTweets: tweetsToSave
                        .map((tweet) => tweet.id)
                        .join(","),
                });

                // Save the missing tweets as memories
                for (const tweet of tweetsToSave) {
                    elizaLogger.log("Saving Tweet", tweet.id);

                    const roomId = stringToUuid(
                        tweet.conversationId + "-" + this.runtime.agentId
                    );

                    const userId =
                        tweet.userId === this.profile.id
                            ? this.runtime.agentId
                            : stringToUuid(tweet.userId);

                    if (tweet.userId === this.profile.id) {
                        await this.runtime.ensureConnection(
                            this.runtime.agentId,
                            roomId,
                            this.profile.username,
                            this.profile.screenName,
                            "twitter"
                        );
                    } else {
                        await this.runtime.ensureConnection(
                            userId,
                            roomId,
                            tweet.username,
                            tweet.name,
                            "twitter"
                        );
                    }

                    const content = {
                        text: tweet.text,
                        url: tweet.permanentUrl,
                        source: "twitter",
                        inReplyTo: tweet.inReplyToStatusId
                            ? stringToUuid(
                                  tweet.inReplyToStatusId +
                                      "-" +
                                      this.runtime.agentId
                              )
                            : undefined,
                    } as Content;

                    elizaLogger.log("Creating memory for tweet", tweet.id);

                    // check if it already exists
                    const memory =
                        await this.runtime.messageManager.getMemoryById(
                            stringToUuid(tweet.id + "-" + this.runtime.agentId)
                        );

                    if (memory) {
                        elizaLogger.log(
                            "Memory already exists, skipping timeline population"
                        );
                        break;
                    }

                    await this.runtime.messageManager.createMemory({
                        id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
                        userId,
                        content: content,
                        agentId: this.runtime.agentId,
                        roomId,
                        embedding: getEmbeddingZeroVector(),
                        createdAt: tweet.timestamp * 1000,
                    });

                    await this.cacheTweet(tweet);
                }

                elizaLogger.log(
                    `Populated ${tweetsToSave.length} missing tweets from the cache.`
                );
                return;
            }
        }

        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);
        const username = this.twitterConfig.TWITTER_USERNAME;

        // Get the most recent 20 mentions and interactions
        const mentionsAndInteractions = await this.fetchSearchTweets(
            `@${username}`,
            20,
            SearchMode.Latest
        );

        // Combine the timeline tweets and mentions/interactions
        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];

        // Create a Set to store unique tweet IDs
        const tweetIdsToCheck = new Set<string>();
        const roomIds = new Set<UUID>();

        // Add tweet IDs to the Set
        for (const tweet of allTweets) {
            tweetIdsToCheck.add(tweet.id);
            roomIds.add(
                stringToUuid(tweet.conversationId + "-" + this.runtime.agentId)
            );
        }

        // Check the existing memories in the database
        const existingMemories =
            await this.runtime.messageManager.getMemoriesByRoomIds({
                roomIds: Array.from(roomIds),
            });

        // Create a Set to store the existing memory IDs
        const existingMemoryIds = new Set<UUID>(
            existingMemories.map((memory) => memory.id)
        );

        // Filter out the tweets that already exist in the database
        const tweetsToSave = allTweets.filter(
            (tweet) =>
                !existingMemoryIds.has(
                    stringToUuid(tweet.id + "-" + this.runtime.agentId)
                )
        );

        elizaLogger.debug({
            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(","),
        });

        await this.runtime.ensureUserExists(
            this.runtime.agentId,
            this.profile.username,
            this.runtime.character.name,
            "twitter"
        );

        // Save the new tweets as memories
        for (const tweet of tweetsToSave) {
            elizaLogger.log("Saving Tweet", tweet.id);

            const roomId = stringToUuid(
                tweet.conversationId + "-" + this.runtime.agentId
            );
            const userId =
                tweet.userId === this.profile.id
                    ? this.runtime.agentId
                    : stringToUuid(tweet.userId);

            if (tweet.userId === this.profile.id) {
                await this.runtime.ensureConnection(
                    this.runtime.agentId,
                    roomId,
                    this.profile.username,
                    this.profile.screenName,
                    "twitter"
                );
            } else {
                await this.runtime.ensureConnection(
                    userId,
                    roomId,
                    tweet.username,
                    tweet.name,
                    "twitter"
                );
            }

            const content = {
                text: tweet.text,
                url: tweet.permanentUrl,
                source: "twitter",
                inReplyTo: tweet.inReplyToStatusId
                    ? stringToUuid(tweet.inReplyToStatusId)
                    : undefined,
            } as Content;

            await this.runtime.messageManager.createMemory({
                id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
                userId,
                content: content,
                agentId: this.runtime.agentId,
                roomId,
                embedding: getEmbeddingZeroVector(),
                createdAt: tweet.timestamp * 1000,
            });

            await this.cacheTweet(tweet);
        }

        // Cache
        await this.cacheTimeline(timeline);
        await this.cacheMentions(mentionsAndInteractions.tweets);
    }

    async setCookiesFromArray(cookiesArray: any[]) {
        const cookieStrings = cookiesArray.map(
            (cookie) =>
                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${
                    cookie.secure ? "Secure" : ""
                }; ${cookie.httpOnly ? "HttpOnly" : ""}; SameSite=${
                    cookie.sameSite || "Lax"
                }`
        );
        await this.twitterClient.setCookies(cookieStrings);
    }

    async saveRequestMessage(message: Memory, state: State) {
        if (message.content.text) {
            const recentMessage = await this.runtime.messageManager.getMemories(
                {
                    roomId: message.roomId,
                    count: 1,
                    unique: false,
                }
            );

            if (
                recentMessage.length > 0 &&
                recentMessage[0].content === message.content
            ) {
                elizaLogger.debug("Message already saved", recentMessage[0].id);
            } else {
                await this.runtime.messageManager.createMemory({
                    ...message,
                    embedding: getEmbeddingZeroVector(),
                });
            }

            await this.runtime.evaluate(message, {
                ...state,
                twitterClient: this.twitterClient,
            });
        }
    }

    async loadLatestCheckedTweetId(): Promise<void> {
        const latestCheckedTweetId =
            await this.runtime.cacheManager.get<string>(
                `twitter/${this.profile.username}/latest_checked_tweet_id`
            );

        if (latestCheckedTweetId) {
            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);
        }
    }

    async cacheLatestCheckedTweetId() {
        if (this.lastCheckedTweetId) {
            await this.runtime.cacheManager.set(
                `twitter/${this.profile.username}/latest_checked_tweet_id`,
                this.lastCheckedTweetId.toString()
            );
        }
    }

    async getCachedTimeline(): Promise<Tweet[] | undefined> {
        return await this.runtime.cacheManager.get<Tweet[]>(
            `twitter/${this.profile.username}/timeline`
        );
    }

    async cacheTimeline(timeline: Tweet[]) {
        await this.runtime.cacheManager.set(
            `twitter/${this.profile.username}/timeline`,
            timeline,
            { expires: Date.now() + 10 * 1000 }
        );
    }

    async cacheMentions(mentions: Tweet[]) {
        await this.runtime.cacheManager.set(
            `twitter/${this.profile.username}/mentions`,
            mentions,
            { expires: Date.now() + 10 * 1000 }
        );
    }

    async getCachedCookies(username: string) {
        return await this.runtime.cacheManager.get<any[]>(
            `twitter/${username}/cookies`
        );
    }

    async cacheCookies(username: string, cookies: any[]) {
        await this.runtime.cacheManager.set(
            `twitter/${username}/cookies`,
            cookies
        );
    }

    async fetchProfile(username: string): Promise<TwitterProfile> {
        try {
            const profile = await this.requestQueue.add(async () => {
                const profile = await this.twitterClient.getProfile(username);
                return {
                    id: profile.userId,
                    username,
                    screenName: profile.name || this.runtime.character.name,
                    bio:
                        profile.biography ||
                        typeof this.runtime.character.bio === "string"
                            ? (this.runtime.character.bio as string)
                            : this.runtime.character.bio.length > 0
                              ? this.runtime.character.bio[0]
                              : "",
                    nicknames:
                        this.runtime.character.twitterProfile?.nicknames || [],
                } satisfies TwitterProfile;
            });

            return profile;
        } catch (error) {
            console.error("Error fetching Twitter profile:", error);
            throw error;
        }
    }
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/interactions.ts`:

```ts
import { SearchMode, type Tweet } from "agent-twitter-client";
import {
    composeContext,
    generateMessageResponse,
    generateShouldRespond,
    messageCompletionFooter,
    shouldRespondFooter,
    type Content,
    type HandlerCallback,
    type IAgentRuntime,
    type Memory,
    ModelClass,
    type State,
    stringToUuid,
    elizaLogger,
    getEmbeddingZeroVector,
    type IImageDescriptionService,
    ServiceType
} from "@elizaos/core";
import type { ClientBase } from "./base";
import { buildConversationThread, sendTweet, wait } from "./utils.ts";

export const twitterMessageHandlerTemplate =
    `
# Areas of Expertise
{{knowledge}}

# About {{agentName}} (@{{twitterUserName}}):
{{bio}}
{{lore}}
{{topics}}

{{providers}}

{{characterPostExamples}}

{{postDirections}}

Recent interactions between {{agentName}} and other users:
{{recentPostInteractions}}

{{recentPosts}}

# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:

Current Post:
{{currentPost}}
Here is the descriptions of images in the Current post.
{{imageDescriptions}}

Thread of Tweets You Are Replying To:
{{formattedConversation}}

# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:
{{actionNames}}
{{actions}}

Here is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)
{{currentPost}}
Here is the descriptions of images in the Current post.
{{imageDescriptions}}
` + messageCompletionFooter;

export const twitterShouldRespondTemplate = (targetUsersStr: string) =>
    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with "true" or "false".

Response options are RESPOND, IGNORE and STOP.

PRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.

For other users:
- {{agentName}} should RESPOND to messages directed at them
- {{agentName}} should RESPOND to conversations relevant to their background
- {{agentName}} should IGNORE irrelevant messages
- {{agentName}} should IGNORE very short messages unless directly addressed
- {{agentName}} should STOP if asked to stop
- {{agentName}} should STOP if conversation is concluded
- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.

IMPORTANT:
- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.
- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.

Recent Posts:
{{recentPosts}}

Current Post:
{{currentPost}}

Thread of Tweets You Are Replying To:
{{formattedConversation}}

# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.
` + shouldRespondFooter;

export class TwitterInteractionClient {
    client: ClientBase;
    runtime: IAgentRuntime;
    private isDryRun: boolean;
    constructor(client: ClientBase, runtime: IAgentRuntime) {
        this.client = client;
        this.runtime = runtime;
        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;
    }

    async start() {
        const handleTwitterInteractionsLoop = () => {
            this.handleTwitterInteractions();
            setTimeout(
                handleTwitterInteractionsLoop,
                // Defaults to 2 minutes
                this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000
            );
        };
        handleTwitterInteractionsLoop();
    }

    async handleTwitterInteractions() {
        elizaLogger.log("Checking Twitter interactions");

        const twitterUsername = this.client.profile.username;
        try {
            // Check for mentions
            const mentionCandidates = (
                await this.client.fetchSearchTweets(
                    `@${twitterUsername}`,
                    20,
                    SearchMode.Latest
                )
            ).tweets;

            elizaLogger.log(
                "Completed checking mentioned tweets:",
                mentionCandidates.length
            );
            let uniqueTweetCandidates = [...mentionCandidates];
            // Only process target users if configured
            if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {
                const TARGET_USERS =
                    this.client.twitterConfig.TWITTER_TARGET_USERS;

                elizaLogger.log("Processing target users:", TARGET_USERS);

                if (TARGET_USERS.length > 0) {
                    // Create a map to store tweets by user
                    const tweetsByUser = new Map<string, Tweet[]>();

                    // Fetch tweets from all target users
                    for (const username of TARGET_USERS) {
                        try {
                            const userTweets = (
                                await this.client.twitterClient.fetchSearchTweets(
                                    `from:${username}`,
                                    3,
                                    SearchMode.Latest
                                )
                            ).tweets;

                            // Filter for unprocessed, non-reply, recent tweets
                            const validTweets = userTweets.filter((tweet) => {
                                const isUnprocessed =
                                    !this.client.lastCheckedTweetId ||
                                    Number.parseInt(tweet.id) >
                                        this.client.lastCheckedTweetId;
                                const isRecent =
                                    Date.now() - tweet.timestamp * 1000 <
                                    2 * 60 * 60 * 1000;

                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {
                                    isUnprocessed,
                                    isRecent,
                                    isReply: tweet.isReply,
                                    isRetweet: tweet.isRetweet,
                                });

                                return (
                                    isUnprocessed &&
                                    !tweet.isReply &&
                                    !tweet.isRetweet &&
                                    isRecent
                                );
                            });

                            if (validTweets.length > 0) {
                                tweetsByUser.set(username, validTweets);
                                elizaLogger.log(
                                    `Found ${validTweets.length} valid tweets from ${username}`
                                );
                            }
                        } catch (error) {
                            elizaLogger.error(
                                `Error fetching tweets for ${username}:`,
                                error
                            );
                            continue;
                        }
                    }

                    // Select one tweet from each user that has tweets
                    const selectedTweets: Tweet[] = [];
                    for (const [username, tweets] of tweetsByUser) {
                        if (tweets.length > 0) {
                            // Randomly select one tweet from this user
                            const randomTweet =
                                tweets[
                                    Math.floor(Math.random() * tweets.length)
                                ];
                            selectedTweets.push(randomTweet);
                            elizaLogger.log(
                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`
                            );
                        }
                    }

                    // Add selected tweets to candidates
                    uniqueTweetCandidates = [
                        ...mentionCandidates,
                        ...selectedTweets,
                    ];
                }
            } else {
                elizaLogger.log(
                    "No target users configured, processing only mentions"
                );
            }

            // Sort tweet candidates by ID in ascending order
            uniqueTweetCandidates
                .sort((a, b) => a.id.localeCompare(b.id))
                .filter((tweet) => tweet.userId !== this.client.profile.id);

            // for each tweet candidate, handle the tweet
            for (const tweet of uniqueTweetCandidates) {
                if (
                    !this.client.lastCheckedTweetId ||
                    BigInt(tweet.id) > this.client.lastCheckedTweetId
                ) {
                    // Generate the tweetId UUID the same way it's done in handleTweet
                    const tweetId = stringToUuid(
                        tweet.id + "-" + this.runtime.agentId
                    );

                    // Check if we've already processed this tweet
                    const existingResponse =
                        await this.runtime.messageManager.getMemoryById(
                            tweetId
                        );

                    if (existingResponse) {
                        elizaLogger.log(
                            `Already responded to tweet ${tweet.id}, skipping`
                        );
                        continue;
                    }
                    elizaLogger.log("New Tweet found", tweet.permanentUrl);

                    const roomId = stringToUuid(
                        tweet.conversationId + "-" + this.runtime.agentId
                    );

                    const userIdUUID =
                        tweet.userId === this.client.profile.id
                            ? this.runtime.agentId
                            : stringToUuid(tweet.userId!);

                    await this.runtime.ensureConnection(
                        userIdUUID,
                        roomId,
                        tweet.username,
                        tweet.name,
                        "twitter"
                    );

                    const thread = await buildConversationThread(
                        tweet,
                        this.client
                    );

                    const message = {
                        content: { 
                            text: tweet.text,
                            imageUrls: tweet.photos?.map(photo => photo.url) || []
                        },
                        agentId: this.runtime.agentId,
                        userId: userIdUUID,
                        roomId,
                    };

                    await this.handleTweet({
                        tweet,
                        message,
                        thread,
                    });

                    // Update the last checked tweet ID after processing each tweet
                    this.client.lastCheckedTweetId = BigInt(tweet.id);
                }
            }

            // Save the latest checked tweet ID to the file
            await this.client.cacheLatestCheckedTweetId();

            elizaLogger.log("Finished checking Twitter interactions");
        } catch (error) {
            elizaLogger.error("Error handling Twitter interactions:", error);
        }
    }

    private async handleTweet({
        tweet,
        message,
        thread,
    }: {
        tweet: Tweet;
        message: Memory;
        thread: Tweet[];
    }) {
        // Only skip if tweet is from self AND not from a target user
        if (tweet.userId === this.client.profile.id &&
            !this.client.twitterConfig.TWITTER_TARGET_USERS.includes(tweet.username)) {
            return;
        }

        if (!message.content.text) {
            elizaLogger.log("Skipping Tweet with no text", tweet.id);
            return { text: "", action: "IGNORE" };
        }

        elizaLogger.log("Processing Tweet: ", tweet.id);
        const formatTweet = (tweet: Tweet) => {
            return `  ID: ${tweet.id}
  From: ${tweet.name} (@${tweet.username})
  Text: ${tweet.text}`;
        };
        const currentPost = formatTweet(tweet);

        const formattedConversation = thread
            .map(
                (tweet) => `@${tweet.username} (${new Date(
                    tweet.timestamp * 1000
                ).toLocaleString("en-US", {
                    hour: "2-digit",
                    minute: "2-digit",
                    month: "short",
                    day: "numeric",
                })}):
        ${tweet.text}`
            )
            .join("\n\n");

        const imageDescriptionsArray = [];
        try{
            for (const photo of tweet.photos) {
                const description = await this.runtime
                    .getService<IImageDescriptionService>(
                        ServiceType.IMAGE_DESCRIPTION
                    )
                    .describeImage(photo.url);
                imageDescriptionsArray.push(description);
            }
        } catch (error) {
    // Handle the error
    elizaLogger.error("Error Occured during describing image: ", error);
}




        let state = await this.runtime.composeState(message, {
            twitterClient: this.client.twitterClient,
            twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,
            currentPost,
            formattedConversation,
            imageDescriptions: imageDescriptionsArray.length > 0
            ? `\nImages in Tweet:\n${imageDescriptionsArray.map((desc, i) =>
              `Image ${i + 1}: Title: ${desc.title}\nDescription: ${desc.description}`).join("\n\n")}`:""
        });

        // check if the tweet exists, save if it doesn't
        const tweetId = stringToUuid(tweet.id + "-" + this.runtime.agentId);
        const tweetExists =
            await this.runtime.messageManager.getMemoryById(tweetId);

        if (!tweetExists) {
            elizaLogger.log("tweet does not exist, saving");
            const userIdUUID = stringToUuid(tweet.userId as string);
            const roomId = stringToUuid(tweet.conversationId);

            const message = {
                id: tweetId,
                agentId: this.runtime.agentId,
                content: {
                    text: tweet.text,
                    url: tweet.permanentUrl,
                    imageUrls: tweet.photos?.map(photo => photo.url) || [],
                    inReplyTo: tweet.inReplyToStatusId
                        ? stringToUuid(
                              tweet.inReplyToStatusId +
                                  "-" +
                                  this.runtime.agentId
                          )
                        : undefined,
                },
                userId: userIdUUID,
                roomId,
                createdAt: tweet.timestamp * 1000,
            };
            this.client.saveRequestMessage(message, state);
        }

        // get usernames into str
        const validTargetUsersStr =
            this.client.twitterConfig.TWITTER_TARGET_USERS.join(",");

        const shouldRespondContext = composeContext({
            state,
            template:
                this.runtime.character.templates
                    ?.twitterShouldRespondTemplate ||
                this.runtime.character?.templates?.shouldRespondTemplate ||
                twitterShouldRespondTemplate(validTargetUsersStr),
        });

        const shouldRespond = await generateShouldRespond({
            runtime: this.runtime,
            context: shouldRespondContext,
            modelClass: ModelClass.MEDIUM,
        });

        // Promise<"RESPOND" | "IGNORE" | "STOP" | null> {
        if (shouldRespond !== "RESPOND") {
            elizaLogger.log("Not responding to message");
            return { text: "Response Decision:", action: shouldRespond };
        }

        const context = composeContext({
            state: {
                ...state,
                // Convert actionNames array to string
                actionNames: Array.isArray(state.actionNames)
                    ? state.actionNames.join(', ')
                    : state.actionNames || '',
                actions: Array.isArray(state.actions)
                    ? state.actions.join('\n')
                    : state.actions || '',
                // Ensure character examples are included
                characterPostExamples: this.runtime.character.messageExamples
                    ? this.runtime.character.messageExamples
                        .map(example =>
                            example.map(msg =>
                                `${msg.user}: ${msg.content.text}${msg.content.action ? ` [Action: ${msg.content.action}]` : ''}`
                            ).join('\n')
                        ).join('\n\n')
                    : '',
            },
            template:
                this.runtime.character.templates
                    ?.twitterMessageHandlerTemplate ||
                this.runtime.character?.templates?.messageHandlerTemplate ||
                twitterMessageHandlerTemplate,
        });

        const response = await generateMessageResponse({
            runtime: this.runtime,
            context,
            modelClass: ModelClass.LARGE,
        });

        const removeQuotes = (str: string) =>
            str.replace(/^['"](.*)['"]$/, "$1");

        const stringId = stringToUuid(tweet.id + "-" + this.runtime.agentId);

        response.inReplyTo = stringId;

        response.text = removeQuotes(response.text);

        if (response.text) {
            if (this.isDryRun) {
                elizaLogger.info(
                    `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\nAgent's Output:\n${response.text}`
                );
            } else {
                try {
                    const callback: HandlerCallback = async (
                        response: Content,
                        tweetId?: string
                    ) => {
                        const memories = await sendTweet(
                            this.client,
                            response,
                            message.roomId,
                            this.client.twitterConfig.TWITTER_USERNAME,
                            tweetId || tweet.id
                        );
                        return memories;
                    };

                    const action = this.runtime.actions.find((a) => a.name === response.action);
                    const shouldSuppressInitialMessage = action?.suppressInitialMessage;

                    let responseMessages = [];

                    if (!shouldSuppressInitialMessage) {
                        responseMessages = await callback(response);
                    } else {
                        responseMessages = [{
                            id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
                            userId: this.runtime.agentId,
                            agentId: this.runtime.agentId,
                            content: response,
                            roomId: message.roomId,
                            embedding: getEmbeddingZeroVector(),
                            createdAt: Date.now(),
                        }];
                    }

                    state = (await this.runtime.updateRecentMessageState(
                        state
                    )) as State;

                    for (const responseMessage of responseMessages) {
                        if (
                            responseMessage ===
                            responseMessages[responseMessages.length - 1]
                        ) {
                            responseMessage.content.action = response.action;
                        } else {
                            responseMessage.content.action = "CONTINUE";
                        }
                        await this.runtime.messageManager.createMemory(
                            responseMessage
                        );
                    }

                    const responseTweetId =
                    responseMessages[responseMessages.length - 1]?.content
                        ?.tweetId;

                    await this.runtime.processActions(
                        message,
                        responseMessages,
                        state,
                        (response: Content) => {
                            return callback(response, responseTweetId);
                        }
                    );

                    const responseInfo = `Context:\n\n${context}\n\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\nAgent's Output:\n${response.text}`;

                    await this.runtime.cacheManager.set(
                        `twitter/tweet_generation_${tweet.id}.txt`,
                        responseInfo
                    );
                    await wait();
                } catch (error) {
                    elizaLogger.error(`Error sending response tweet: ${error}`);
                }
            }
        }
    }

    async buildConversationThread(
        tweet: Tweet,
        maxReplies = 10
    ): Promise<Tweet[]> {
        const thread: Tweet[] = [];
        const visited: Set<string> = new Set();

        async function processThread(currentTweet: Tweet, depth = 0) {
            elizaLogger.log("Processing tweet:", {
                id: currentTweet.id,
                inReplyToStatusId: currentTweet.inReplyToStatusId,
                depth: depth,
            });

            if (!currentTweet) {
                elizaLogger.log("No current tweet found for thread building");
                return;
            }

            if (depth >= maxReplies) {
                elizaLogger.log("Reached maximum reply depth", depth);
                return;
            }

            // Handle memory storage
            const memory = await this.runtime.messageManager.getMemoryById(
                stringToUuid(currentTweet.id + "-" + this.runtime.agentId)
            );
            if (!memory) {
                const roomId = stringToUuid(
                    currentTweet.conversationId + "-" + this.runtime.agentId
                );
                const userId = stringToUuid(currentTweet.userId);

                await this.runtime.ensureConnection(
                    userId,
                    roomId,
                    currentTweet.username,
                    currentTweet.name,
                    "twitter"
                );

                this.runtime.messageManager.createMemory({
                    id: stringToUuid(
                        currentTweet.id + "-" + this.runtime.agentId
                    ),
                    agentId: this.runtime.agentId,
                    content: {
                        text: currentTweet.text,
                        source: "twitter",
                        url: currentTweet.permanentUrl,
                        imageUrls: currentTweet.photos?.map(photo => photo.url) || [],
                        inReplyTo: currentTweet.inReplyToStatusId
                            ? stringToUuid(
                                  currentTweet.inReplyToStatusId +
                                      "-" +
                                      this.runtime.agentId
                              )
                            : undefined,
                    },
                    createdAt: currentTweet.timestamp * 1000,
                    roomId,
                    userId:
                        currentTweet.userId === this.twitterUserId
                            ? this.runtime.agentId
                            : stringToUuid(currentTweet.userId),
                    embedding: getEmbeddingZeroVector(),
                });
            }

            if (visited.has(currentTweet.id)) {
                elizaLogger.log("Already visited tweet:", currentTweet.id);
                return;
            }

            visited.add(currentTweet.id);
            thread.unshift(currentTweet);

            if (currentTweet.inReplyToStatusId) {
                elizaLogger.log(
                    "Fetching parent tweet:",
                    currentTweet.inReplyToStatusId
                );
                try {
                    const parentTweet = await this.twitterClient.getTweet(
                        currentTweet.inReplyToStatusId
                    );

                    if (parentTweet) {
                        elizaLogger.log("Found parent tweet:", {
                            id: parentTweet.id,
                            text: parentTweet.text?.slice(0, 50),
                        });
                        await processThread(parentTweet, depth + 1);
                    } else {
                        elizaLogger.log(
                            "No parent tweet found for:",
                            currentTweet.inReplyToStatusId
                        );
                    }
                } catch (error) {
                    elizaLogger.log("Error fetching parent tweet:", {
                        tweetId: currentTweet.inReplyToStatusId,
                        error,
                    });
                }
            } else {
                elizaLogger.log(
                    "Reached end of reply chain at:",
                    currentTweet.id
                );
            }
        }

        // Need to bind this context for the inner function
        await processThread.bind(this)(tweet, 0);

        return thread;
    }
}
```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/search.ts`:

```ts
import { SearchMode } from "agent-twitter-client";
import { composeContext, elizaLogger } from "@elizaos/core";
import { generateMessageResponse, generateText } from "@elizaos/core";
import { messageCompletionFooter } from "@elizaos/core";
import {
    type Content,
    type HandlerCallback,
    type IAgentRuntime,
    type IImageDescriptionService,
    ModelClass,
    ServiceType,
    type State,
} from "@elizaos/core";
import { stringToUuid } from "@elizaos/core";
import type { ClientBase } from "./base";
import { buildConversationThread, sendTweet, wait } from "./utils.ts";

const twitterSearchTemplate =
    `{{timeline}}

{{providers}}

Recent interactions between {{agentName}} and other users:
{{recentPostInteractions}}

About {{agentName}} (@{{twitterUserName}}):
{{bio}}
{{lore}}
{{topics}}

{{postDirections}}

{{recentPosts}}

# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.
{{currentPost}}

IMPORTANT: Your response CANNOT be longer than 20 words.
Aim for 1-2 short sentences maximum. Be concise and direct.

Your response should not contain any questions. Brief, concise statements only. No emojis. Use \\n\\n (double spaces) between statements.

` + messageCompletionFooter;

export class TwitterSearchClient {
    client: ClientBase;
    runtime: IAgentRuntime;
    twitterUsername: string;
    private respondedTweets: Set<string> = new Set();

    constructor(client: ClientBase, runtime: IAgentRuntime) {
        this.client = client;
        this.runtime = runtime;
        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;
    }

    async start() {
        this.engageWithSearchTermsLoop();
    }

    private engageWithSearchTermsLoop() {
        this.engageWithSearchTerms().then();
        const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
        elizaLogger.log(
            `Next twitter search scheduled in ${randomMinutes} minutes`
        );
        setTimeout(
            () => this.engageWithSearchTermsLoop(),
            randomMinutes * 60 * 1000
        );
    }

    private async engageWithSearchTerms() {
        elizaLogger.log("Engaging with search terms");
        try {
            const searchTerm = [...this.runtime.character.topics][
                Math.floor(Math.random() * this.runtime.character.topics.length)
            ];

            elizaLogger.log("Fetching search tweets");
            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue
            await new Promise((resolve) => setTimeout(resolve, 5000));
            const recentTweets = await this.client.fetchSearchTweets(
                searchTerm,
                20,
                SearchMode.Top
            );
            elizaLogger.log("Search tweets fetched");

            const homeTimeline = await this.client.fetchHomeTimeline(50);

            await this.client.cacheTimeline(homeTimeline);

            const formattedHomeTimeline =
                `# ${this.runtime.character.name}'s Home Timeline\n\n` +
                homeTimeline
                    .map((tweet) => {
                        return `ID: ${tweet.id}\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ""}\nText: ${tweet.text}\n---\n`;
                    })
                    .join("\n");

            // randomly slice .tweets down to 20
            const slicedTweets = recentTweets.tweets
                .sort(() => Math.random() - 0.5)
                .slice(0, 20);

            if (slicedTweets.length === 0) {
                elizaLogger.log(
                    "No valid tweets found for the search term",
                    searchTerm
                );
                return;
            }

            const prompt = `
  Here are some tweets related to the search term "${searchTerm}":

  ${[...slicedTweets, ...homeTimeline]
      .filter((tweet) => {
          // ignore tweets where any of the thread tweets contain a tweet by the bot
          const thread = tweet.thread;
          const botTweet = thread.find(
              (t) => t.username === this.twitterUsername
          );
          return !botTweet;
      })
      .map(
          (tweet) => `
    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ""}
    From: ${tweet.name} (@${tweet.username})
    Text: ${tweet.text}
  `
      )
      .join("\n")}

  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.
  Notes:
    - Respond to English tweets only
    - Respond to tweets that don't have a lot of hashtags, links, URLs or images
    - Respond to tweets that are not retweets
    - Respond to tweets where there is an easy exchange of ideas to have with the user
    - ONLY respond with the ID of the tweet`;

            const mostInterestingTweetResponse = await generateText({
                runtime: this.runtime,
                context: prompt,
                modelClass: ModelClass.SMALL,
            });

            const tweetId = mostInterestingTweetResponse.trim();
            const selectedTweet = slicedTweets.find(
                (tweet) =>
                    tweet.id.toString().includes(tweetId) ||
                    tweetId.includes(tweet.id.toString())
            );

            if (!selectedTweet) {
                elizaLogger.warn("No matching tweet found for the selected ID");
                elizaLogger.log("Selected tweet ID:", tweetId);
                return;
            }

            elizaLogger.log("Selected tweet to reply to:", selectedTweet?.text);

            if (selectedTweet.username === this.twitterUsername) {
                elizaLogger.log("Skipping tweet from bot itself");
                return;
            }

            const conversationId = selectedTweet.conversationId;
            const roomId = stringToUuid(
                conversationId + "-" + this.runtime.agentId
            );

            const userIdUUID = stringToUuid(selectedTweet.userId as string);

            await this.runtime.ensureConnection(
                userIdUUID,
                roomId,
                selectedTweet.username,
                selectedTweet.name,
                "twitter"
            );

            // crawl additional conversation tweets, if there are any
            await buildConversationThread(selectedTweet, this.client);

            const message = {
                id: stringToUuid(selectedTweet.id + "-" + this.runtime.agentId),
                agentId: this.runtime.agentId,
                content: {
                    text: selectedTweet.text,
                    url: selectedTweet.permanentUrl,
                    inReplyTo: selectedTweet.inReplyToStatusId
                        ? stringToUuid(
                              selectedTweet.inReplyToStatusId +
                                  "-" +
                                  this.runtime.agentId
                          )
                        : undefined,
                },
                userId: userIdUUID,
                roomId,
                // Timestamps are in seconds, but we need them in milliseconds
                createdAt: selectedTweet.timestamp * 1000,
            };

            if (!message.content.text) {
                elizaLogger.warn("Returning: No response text found");
                return;
            }

            // Fetch replies and retweets
            const replies = selectedTweet.thread;
            const replyContext = replies
                .filter((reply) => reply.username !== this.twitterUsername)
                .map((reply) => `@${reply.username}: ${reply.text}`)
                .join("\n");

            let tweetBackground = "";
            if (selectedTweet.isRetweet) {
                const originalTweet = await this.client.requestQueue.add(() =>
                    this.client.twitterClient.getTweet(selectedTweet.id)
                );
                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;
            }

            // Generate image descriptions using GPT-4 vision API
            const imageDescriptions = [];
            for (const photo of selectedTweet.photos) {
                const description = await this.runtime
                    .getService<IImageDescriptionService>(
                        ServiceType.IMAGE_DESCRIPTION
                    )
                    .describeImage(photo.url);
                imageDescriptions.push(description);
            }

            let state = await this.runtime.composeState(message, {
                twitterClient: this.client.twitterClient,
                twitterUserName: this.twitterUsername,
                timeline: formattedHomeTimeline,
                tweetContext: `${tweetBackground}

  Original Post:
  By @${selectedTweet.username}
  ${selectedTweet.text}${replyContext.length > 0 && `\nReplies to original post:\n${replyContext}`}
  ${`Original post text: ${selectedTweet.text}`}
  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(", ")}\n` : ""}${imageDescriptions.length > 0 ? `\nImages in Post (Described): ${imageDescriptions.join(", ")}\n` : ""}
  `,
            });

            await this.client.saveRequestMessage(message, state as State);

            const context = composeContext({
                state,
                template:
                    this.runtime.character.templates?.twitterSearchTemplate ||
                    twitterSearchTemplate,
            });

            const responseContent = await generateMessageResponse({
                runtime: this.runtime,
                context,
                modelClass: ModelClass.LARGE,
            });

            responseContent.inReplyTo = message.id;

            const response = responseContent;

            if (!response.text) {
                elizaLogger.warn("Returning: No response text found");
                return;
            }

            elizaLogger.log(
                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`
            );
            try {
                const callback: HandlerCallback = async (response: Content) => {
                    const memories = await sendTweet(
                        this.client,
                        response,
                        message.roomId,
                        this.twitterUsername,
                        selectedTweet.id
                    );
                    return memories;
                };

                const responseMessages = await callback(responseContent);

                state = await this.runtime.updateRecentMessageState(state);

                for (const responseMessage of responseMessages) {
                    await this.runtime.messageManager.createMemory(
                        responseMessage,
                        false
                    );
                }

                state = await this.runtime.updateRecentMessageState(state);

                await this.runtime.evaluate(message, state);

                await this.runtime.processActions(
                    message,
                    responseMessages,
                    state,
                    callback
                );

                this.respondedTweets.add(selectedTweet.id);
                const responseInfo = `Context:\n\n${context}\n\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\nAgent's Output:\n${response.text}`;

                await this.runtime.cacheManager.set(
                    `twitter/tweet_generation_${selectedTweet.id}.txt`,
                    responseInfo
                );

                await wait();
            } catch (error) {
                console.error(`Error sending response post: ${error}`);
            }
        } catch (error) {
            console.error("Error engaging with search terms:", error);
        }
    }
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/plugins/templates.ts`:

```ts
import { messageCompletionFooter, shouldRespondFooter } from "@elizaos/core";

export const twitterShouldRespondTemplate =
    `# Task: Decide if {{agentName}} should respond.
About {{agentName}}:
{{bio}}

# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with "RESPOND" or "IGNORE" or "STOP".

# RESPONSE EXAMPLES
{{user1}}: I just saw a really great movie
{{user2}}: Oh? Which movie?
Result: [IGNORE]

{{agentName}}: Oh, this is my favorite scene
{{user1}}: sick
{{user2}}: wait, why is it your favorite scene
Result: [RESPOND]

{{user1}}: stfu bot
Result: [STOP]

{{user1}}: Hey {{agent}}, can you help me with something
Result: [RESPOND]

{{user1}}: {{agentName}} stfu plz
Result: [STOP]

{{user1}}: i need help
{{agentName}}: how can I help you?
{{user1}}: no. i need help from someone else
Result: [IGNORE]

{{user1}}: Hey {{agent}}, can I ask you a question
{{agentName}}: Sure, what is it
{{user1}}: can you ask claude to create a basic react module that demonstrates a counter
Result: [RESPOND]

{{user1}}: {{agentName}} can you tell me a story
{{user1}}: about a girl named elara
{{agentName}}: Sure.
{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.
{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.
{{user1}}: I'm loving it, keep going
Result: [RESPOND]

{{user1}}: {{agentName}} stop responding plz
Result: [STOP]

{{user1}}: okay, i want to test something. can you say marco?
{{agentName}}: marco
{{user1}}: great. okay, now do it again
Result: [RESPOND]

Response options are [RESPOND], [IGNORE] and [STOP].

{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.
Respond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.
If a message is not interesting or relevant, respond with [IGNORE]
Unless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.
If a user asks {{agentName}} to be quiet, respond with [STOP]
If {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]

IMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].
If {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].

{{recentMessages}}

# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.
` + shouldRespondFooter;

export const twitterVoiceHandlerTemplate =
    `# Task: Generate conversational voice dialog for {{agentName}}.
    About {{agentName}}:
    {{bio}}

    # Attachments
    {{attachments}}

    # Capabilities
    Note that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the "Attachments" section.

    {{actions}}

    {{messageDirections}}

    {{recentMessages}}

    # Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}
    ` + messageCompletionFooter;

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/plugins/SttTtsSpacesPlugin.ts`:

```ts
// src/plugins/SttTtsPlugin.ts

import { spawn } from "child_process";
import {
    type ITranscriptionService,
    elizaLogger,
    stringToUuid,
    composeContext,
    getEmbeddingZeroVector,
    generateMessageResponse,
    ModelClass,
    type Content,
    type IAgentRuntime,
    type Memory,
    type Plugin,
    type UUID,
    type State,
    composeRandomUser,
    generateShouldRespond,
} from "@elizaos/core";
import type {
    Space,
    JanusClient,
    AudioDataWithUser,
} from "agent-twitter-client";
import type { ClientBase } from "../base";
import {
    twitterVoiceHandlerTemplate,
    twitterShouldRespondTemplate,
} from "./templates";

interface PluginConfig {
    runtime: IAgentRuntime;
    client: ClientBase;
    spaceId: string;
    elevenLabsApiKey?: string; // for TTS
    sttLanguage?: string; // e.g. "en" for Whisper
    silenceThreshold?: number; // amplitude threshold for ignoring silence
    voiceId?: string; // specify which ElevenLabs voice to use
    elevenLabsModel?: string; // e.g. "eleven_monolingual_v1"
    chatContext?: Array<{
        role: "system" | "user" | "assistant";
        content: string;
    }>;
    transcriptionService: ITranscriptionService;
}

const VOLUME_WINDOW_SIZE = 100;
const SPEAKING_THRESHOLD = 0.05;
const SILENCE_DETECTION_THRESHOLD_MS = 1000; // 1-second silence threshold

/**
 * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)
 * Approach:
 *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)
 *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus
 */
export class SttTtsPlugin implements Plugin {
    name = "SttTtsPlugin";
    description = "Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)";
    private runtime: IAgentRuntime;
    private client: ClientBase;
    private spaceId: string;

    private space?: Space;
    private janus?: JanusClient;

    private elevenLabsApiKey?: string;

    private voiceId = "21m00Tcm4TlvDq8ikWAM";
    private elevenLabsModel = "eleven_monolingual_v1";
    private chatContext: Array<{
        role: "system" | "user" | "assistant";
        content: string;
    }> = [];

    private transcriptionService: ITranscriptionService;

    /**
     * userId => arrayOfChunks (PCM Int16)
     */
    private pcmBuffers = new Map<string, Int16Array[]>();

    /**
     * For ignoring near-silence frames (if amplitude < threshold)
     */
    private silenceThreshold = 50;

    // TTS queue for sequentially speaking
    private ttsQueue: string[] = [];
    private isSpeaking = false;
    private isProcessingAudio = false;

    private userSpeakingTimer: NodeJS.Timeout | null = null;
    private volumeBuffers: Map<string, number[]>;
    private ttsAbortController: AbortController | null = null;

    onAttach(_space: Space) {
        elizaLogger.log("[SttTtsPlugin] onAttach => space was attached");
    }

    init(params: { space: Space; pluginConfig?: Record<string, any> }): void {
        elizaLogger.log(
            "[SttTtsPlugin] init => Space fully ready. Subscribing to events.",
        );

        this.space = params.space;
        this.janus = (this.space as any)?.janusClient as
            | JanusClient
            | undefined;

        const config = params.pluginConfig as PluginConfig;
        this.runtime = config?.runtime;
        this.client = config?.client;
        this.spaceId = config?.spaceId;
        this.elevenLabsApiKey = config?.elevenLabsApiKey;
        this.transcriptionService = config.transcriptionService;
        if (typeof config?.silenceThreshold === "number") {
            this.silenceThreshold = config.silenceThreshold;
        }
        if (config?.voiceId) {
            this.voiceId = config.voiceId;
        }
        if (config?.elevenLabsModel) {
            this.elevenLabsModel = config.elevenLabsModel;
        }
        if (config?.chatContext) {
            this.chatContext = config.chatContext;
        }

        this.volumeBuffers = new Map<string, number[]>();
    }

    /**
     * Called whenever we receive PCM from a speaker
     */
    onAudioData(data: AudioDataWithUser): void {
        if (this.isProcessingAudio) {
            return;
        }
        let maxVal = 0;
        for (let i = 0; i < data.samples.length; i++) {
            const val = Math.abs(data.samples[i]);
            if (val > maxVal) maxVal = val;
        }
        if (maxVal < this.silenceThreshold) {
            return;
        }

        if (this.userSpeakingTimer) {
            clearTimeout(this.userSpeakingTimer);
        }

        let arr = this.pcmBuffers.get(data.userId);
        if (!arr) {
            arr = [];
            this.pcmBuffers.set(data.userId, arr);
        }
        arr.push(data.samples);

        if (!this.isSpeaking) {
            this.userSpeakingTimer = setTimeout(() => {
                elizaLogger.log(
                    "[SttTtsPlugin] start processing audio for user =>",
                    data.userId,
                );
                this.userSpeakingTimer = null;
                this.processAudio(data.userId).catch((err) =>
                    elizaLogger.error(
                        "[SttTtsPlugin] handleSilence error =>",
                        err,
                    ),
                );
            }, SILENCE_DETECTION_THRESHOLD_MS);
        } else {
            // check interruption
            let volumeBuffer = this.volumeBuffers.get(data.userId);
            if (!volumeBuffer) {
                volumeBuffer = [];
                this.volumeBuffers.set(data.userId, volumeBuffer);
            }
            const samples = new Int16Array(
                data.samples.buffer,
                data.samples.byteOffset,
                data.samples.length / 2,
            );
            const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;
            volumeBuffer.push(maxAmplitude);

            if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {
                volumeBuffer.shift();
            }
            const avgVolume =
                volumeBuffer.reduce((sum, v) => sum + v, 0) /
                VOLUME_WINDOW_SIZE;

            if (avgVolume > SPEAKING_THRESHOLD) {
                volumeBuffer.length = 0;
                if (this.ttsAbortController) {
                    this.ttsAbortController.abort();
                    this.isSpeaking = false;
                    elizaLogger.log("[SttTtsPlugin] TTS playback interrupted");
                }
            }
        }
    }

    // /src/sttTtsPlugin.ts
    private async convertPcmToWavInMemory(
        pcmData: Int16Array,
        sampleRate: number,
    ): Promise<ArrayBuffer> {
        // number of channels
        const numChannels = 1;
        // byte rate = (sampleRate * numChannels * bitsPerSample/8)
        const byteRate = sampleRate * numChannels * 2;
        const blockAlign = numChannels * 2;
        // data chunk size = pcmData.length * (bitsPerSample/8)
        const dataSize = pcmData.length * 2;

        // WAV header is 44 bytes
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        // RIFF chunk descriptor
        this.writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + dataSize, true); // file size - 8
        this.writeString(view, 8, "WAVE");

        // fmt sub-chunk
        this.writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
        view.setUint16(20, 1, true); // AudioFormat (1 = PCM)
        view.setUint16(22, numChannels, true); // NumChannels
        view.setUint32(24, sampleRate, true); // SampleRate
        view.setUint32(28, byteRate, true); // ByteRate
        view.setUint16(32, blockAlign, true); // BlockAlign
        view.setUint16(34, 16, true); // BitsPerSample (16)

        // data sub-chunk
        this.writeString(view, 36, "data");
        view.setUint32(40, dataSize, true);

        // Write PCM samples
        let offset = 44;
        for (let i = 0; i < pcmData.length; i++, offset += 2) {
            view.setInt16(offset, pcmData[i], true);
        }

        return buffer;
    }

    private writeString(view: DataView, offset: number, text: string) {
        for (let i = 0; i < text.length; i++) {
            view.setUint8(offset + i, text.charCodeAt(i));
        }
    }

    /**
     * On speaker silence => flush STT => GPT => TTS => push to Janus
     */
    private async processAudio(userId: string): Promise<void> {
        if (this.isProcessingAudio) {
            return;
        }
        this.isProcessingAudio = true;
        try {
            elizaLogger.log(
                "[SttTtsPlugin] Starting audio processing for user:",
                userId,
            );
            const chunks = this.pcmBuffers.get(userId) || [];
            this.pcmBuffers.clear();

            if (!chunks.length) {
                elizaLogger.warn(
                    "[SttTtsPlugin] No audio chunks for user =>",
                    userId,
                );
                return;
            }
            elizaLogger.log(
                `[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`,
            );

            const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
            const merged = new Int16Array(totalLen);
            let offset = 0;
            for (const c of chunks) {
                merged.set(c, offset);
                offset += c.length;
            }

            // Convert PCM to WAV for STT
            const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);

            // Whisper STT
            const sttText =
                await this.transcriptionService.transcribe(wavBuffer);

            elizaLogger.log(
                `[SttTtsPlugin] Transcription result: "${sttText}"`,
            );

            if (!sttText || !sttText.trim()) {
                elizaLogger.warn(
                    "[SttTtsPlugin] No speech recognized for user =>",
                    userId,
                );
                return;
            }
            elizaLogger.log(
                `[SttTtsPlugin] STT => user=${userId}, text="${sttText}"`,
            );

            // Get response
            const replyText = await this.handleUserMessage(sttText, userId);
            if (!replyText || !replyText.length || !replyText.trim()) {
                elizaLogger.warn(
                    "[SttTtsPlugin] No replyText for user =>",
                    userId,
                );
                return;
            }
            elizaLogger.log(
                `[SttTtsPlugin] user=${userId}, reply="${replyText}"`,
            );
            this.isProcessingAudio = false;
            this.volumeBuffers.clear();
            // Use the standard speak method with queue
            await this.speakText(replyText);
        } catch (error) {
            elizaLogger.error("[SttTtsPlugin] processAudio error =>", error);
        } finally {
            this.isProcessingAudio = false;
        }
    }

    /**
     * Public method to queue a TTS request
     */
    public async speakText(text: string): Promise<void> {
        this.ttsQueue.push(text);
        if (!this.isSpeaking) {
            this.isSpeaking = true;
            this.processTtsQueue().catch((err) => {
                elizaLogger.error(
                    "[SttTtsPlugin] processTtsQueue error =>",
                    err,
                );
            });
        }
    }

    /**
     * Process TTS requests one by one
     */
    private async processTtsQueue(): Promise<void> {
        while (this.ttsQueue.length > 0) {
            const text = this.ttsQueue.shift();
            if (!text) continue;

            this.ttsAbortController = new AbortController();
            const { signal } = this.ttsAbortController;

            try {
                const ttsAudio = await this.elevenLabsTts(text);
                const pcm = await this.convertMp3ToPcm(ttsAudio, 48000);
                if (signal.aborted) {
                    elizaLogger.log(
                        "[SttTtsPlugin] TTS interrupted before streaming",
                    );
                    return;
                }
                await this.streamToJanus(pcm, 48000);
                if (signal.aborted) {
                    elizaLogger.log(
                        "[SttTtsPlugin] TTS interrupted after streaming",
                    );
                    return;
                }
            } catch (err) {
                elizaLogger.error("[SttTtsPlugin] TTS streaming error =>", err);
            } finally {
                // Clean up the AbortController
                this.ttsAbortController = null;
            }
        }
        this.isSpeaking = false;
    }

    /**
     * Handle User Message
     */
    private async handleUserMessage(
        userText: string,
        userId: string, // This is the raw Twitter user ID like 'tw-1865462035586142208'
    ): Promise<string> {
        // Extract the numeric ID part
        const numericId = userId.replace("tw-", "");
        const roomId = stringToUuid(`twitter_generate_room-${this.spaceId}`);

        // Create consistent UUID for the user
        const userUuid = stringToUuid(`twitter-user-${numericId}`);

        // Ensure the user exists in the accounts table
        await this.runtime.ensureUserExists(
            userUuid,
            userId, // Use full Twitter ID as username
            `Twitter User ${numericId}`,
            "twitter",
        );

        // Ensure room exists and user is in it
        await this.runtime.ensureRoomExists(roomId);
        await this.runtime.ensureParticipantInRoom(userUuid, roomId);

        let state = await this.runtime.composeState(
            {
                agentId: this.runtime.agentId,
                content: { text: userText, source: "twitter" },
                userId: userUuid,
                roomId,
            },
            {
                twitterUserName: this.client.profile.username,
                agentName: this.runtime.character.name,
            },
        );

        const memory = {
            id: stringToUuid(`${roomId}-voice-message-${Date.now()}`),
            agentId: this.runtime.agentId,
            content: {
                text: userText,
                source: "twitter",
            },
            userId: userUuid,
            roomId,
            embedding: getEmbeddingZeroVector(),
            createdAt: Date.now(),
        };

        await this.runtime.messageManager.createMemory(memory);

        state = await this.runtime.updateRecentMessageState(state);

        const shouldIgnore = await this._shouldIgnore(memory);

        if (shouldIgnore) {
            return "";
        }

        const shouldRespond = await this._shouldRespond(userText, state);

        if (!shouldRespond) {
            return "";
        }

        const context = composeContext({
            state,
            template:
                this.runtime.character.templates?.twitterVoiceHandlerTemplate ||
                this.runtime.character.templates?.messageHandlerTemplate ||
                twitterVoiceHandlerTemplate,
        });

        const responseContent = await this._generateResponse(memory, context);

        const responseMemory: Memory = {
            id: stringToUuid(`${memory.id}-voice-response-${Date.now()}`),
            agentId: this.runtime.agentId,
            userId: this.runtime.agentId,
            content: {
                ...responseContent,
                user: this.runtime.character.name,
                inReplyTo: memory.id,
            },
            roomId,
            embedding: getEmbeddingZeroVector(),
        };

        const reply = responseMemory.content.text?.trim();
        if (reply) {
            await this.runtime.messageManager.createMemory(responseMemory);
        }

        return reply;
    }

    private async _generateResponse(
        message: Memory,
        context: string,
    ): Promise<Content> {
        const { userId, roomId } = message;

        const response = await generateMessageResponse({
            runtime: this.runtime,
            context,
            modelClass: ModelClass.SMALL,
        });

        response.source = "discord";

        if (!response) {
            elizaLogger.error(
                "[SttTtsPlugin] No response from generateMessageResponse",
            );
            return;
        }

        await this.runtime.databaseAdapter.log({
            body: { message, context, response },
            userId: userId,
            roomId,
            type: "response",
        });

        return response;
    }

    private async _shouldIgnore(message: Memory): Promise<boolean> {
        elizaLogger.debug("message.content: ", message.content);
        // if the message is 3 characters or less, ignore it
        if ((message.content as Content).text.length < 3) {
            return true;
        }

        const loseInterestWords = [
            // telling the bot to stop talking
            "shut up",
            "stop",
            "dont talk",
            "silence",
            "stop talking",
            "be quiet",
            "hush",
            "stfu",
            "stupid bot",
            "dumb bot",

            // offensive words
            "fuck",
            "shit",
            "damn",
            "suck",
            "dick",
            "cock",
            "sex",
            "sexy",
        ];
        if (
            (message.content as Content).text.length < 50 &&
            loseInterestWords.some((word) =>
                (message.content as Content).text?.toLowerCase().includes(word),
            )
        ) {
            return true;
        }

        const ignoreWords = ["k", "ok", "bye", "lol", "nm", "uh"];
        if (
            (message.content as Content).text?.length < 8 &&
            ignoreWords.some((word) =>
                (message.content as Content).text?.toLowerCase().includes(word),
            )
        ) {
            return true;
        }

        return false;
    }

    private async _shouldRespond(
        message: string,
        state: State,
    ): Promise<boolean> {
        const lowerMessage = message.toLowerCase();
        const characterName = this.runtime.character.name.toLowerCase();

        if (lowerMessage.includes(characterName)) {
            return true;
        }

        // If none of the above conditions are met, use the generateText to decide
        const shouldRespondContext = composeContext({
            state,
            template:
                this.runtime.character.templates
                    ?.twitterShouldRespondTemplate ||
                this.runtime.character.templates?.shouldRespondTemplate ||
                composeRandomUser(twitterShouldRespondTemplate, 2),
        });

        const response = await generateShouldRespond({
            runtime: this.runtime,
            context: shouldRespondContext,
            modelClass: ModelClass.SMALL,
        });

        if (response === "RESPOND") {
            return true;
        }

        if (response === "IGNORE" || response === "STOP") {
            return false;
        }

        elizaLogger.error(
            "Invalid response from response generateText:",
            response,
        );
        return false;
    }

    /**
     * ElevenLabs TTS => returns MP3 Buffer
     */
    private async elevenLabsTts(text: string): Promise<Buffer> {
        if (!this.elevenLabsApiKey) {
            throw new Error("[SttTtsPlugin] No ElevenLabs API key");
        }
        const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;
        const resp = await fetch(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "xi-api-key": this.elevenLabsApiKey,
            },
            body: JSON.stringify({
                text,
                model_id: this.elevenLabsModel,
                voice_settings: { stability: 0.4, similarity_boost: 0.8 },
            }),
        });
        if (!resp.ok) {
            const errText = await resp.text();
            throw new Error(
                `[SttTtsPlugin] ElevenLabs TTS error => ${resp.status} ${errText}`,
            );
        }
        const arrayBuf = await resp.arrayBuffer();
        return Buffer.from(arrayBuf);
    }

    /**
     * Convert MP3 => PCM via ffmpeg
     */
    private convertMp3ToPcm(
        mp3Buf: Buffer,
        outRate: number,
    ): Promise<Int16Array> {
        return new Promise((resolve, reject) => {
            const ff = spawn("ffmpeg", [
                "-i",
                "pipe:0",
                "-f",
                "s16le",
                "-ar",
                outRate.toString(),
                "-ac",
                "1",
                "pipe:1",
            ]);
            let raw = Buffer.alloc(0);

            ff.stdout.on("data", (chunk: Buffer) => {
                raw = Buffer.concat([raw, chunk]);
            });
            ff.stderr.on("data", () => {
                // ignoring ffmpeg logs
            });
            ff.on("close", (code) => {
                if (code !== 0) {
                    reject(new Error(`ffmpeg error code=${code}`));
                    return;
                }
                const samples = new Int16Array(
                    raw.buffer,
                    raw.byteOffset,
                    raw.byteLength / 2,
                );
                resolve(samples);
            });

            ff.stdin.write(mp3Buf);
            ff.stdin.end();
        });
    }

    /**
     * Push PCM back to Janus in small frames
     * We'll do 10ms @48k => 960 samples per frame
     */
    private async streamToJanus(
        samples: Int16Array,
        sampleRate: number,
    ): Promise<void> {
        // TODO: Check if better than 480 fixed
        const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz

        for (
            let offset = 0;
            offset + FRAME_SIZE <= samples.length;
            offset += FRAME_SIZE
        ) {
            if (this.ttsAbortController?.signal.aborted) {
                elizaLogger.log("[SttTtsPlugin] streamToJanus interrupted");
                return;
            }
            const frame = new Int16Array(FRAME_SIZE);
            frame.set(samples.subarray(offset, offset + FRAME_SIZE));
            this.janus?.pushLocalAudio(frame, sampleRate, 1);

            // Short pause so we don't overload
            await new Promise((r) => setTimeout(r, 10));
        }
    }

    /**
     * Add a message (system, user or assistant) to the chat context.
     * E.g. to store conversation history or inject a persona.
     */
    public addMessage(role: "system" | "user" | "assistant", content: string) {
        this.chatContext.push({ role, content });
        elizaLogger.log(
            `[SttTtsPlugin] addMessage => role=${role}, content=${content}`,
        );
    }

    /**
     * Clear the chat context if needed.
     */
    public clearChatContext() {
        this.chatContext = [];
        elizaLogger.log("[SttTtsPlugin] clearChatContext => done");
    }

    cleanup(): void {
        elizaLogger.log("[SttTtsPlugin] cleanup => releasing resources");
        this.pcmBuffers.clear();
        this.userSpeakingTimer = null;
        this.ttsQueue = [];
        this.isSpeaking = false;
        this.volumeBuffers.clear();
    }
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/environment.ts`:

```ts
import {
    parseBooleanFromText,
    type IAgentRuntime,
    ActionTimelineType,
} from "@elizaos/core";
import { z, ZodError } from "zod";

export const DEFAULT_MAX_TWEET_LENGTH = 280;

const twitterUsernameSchema = z
    .string()
    .min(1, "An X/Twitter Username must be at least 1 character long")
    .max(15, "An X/Twitter Username cannot exceed 15 characters")
    .refine((username) => {
        // Allow wildcard '*' as a special case
        if (username === "*") return true;

        // Twitter usernames can:
        // - Start with digits now
        // - Contain letters, numbers, underscores
        // - Must not be empty
        return /^[A-Za-z0-9_]+$/.test(username);
    }, "An X Username can only contain letters, numbers, and underscores");

/**
 * This schema defines all required/optional environment settings,
 * including new fields like TWITTER_SPACES_ENABLE.
 */
export const twitterEnvSchema = z.object({
    TWITTER_DRY_RUN: z.boolean(),
    TWITTER_USERNAME: z.string().min(1, "X/Twitter username is required"),
    TWITTER_PASSWORD: z.string().min(1, "X/Twitter password is required"),
    TWITTER_EMAIL: z.string().email("Valid X/Twitter email is required"),
    MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),
    TWITTER_SEARCH_ENABLE: z.boolean().default(false),
    TWITTER_2FA_SECRET: z.string(),
    TWITTER_RETRY_LIMIT: z.number().int(),
    TWITTER_POLL_INTERVAL: z.number().int(),
    TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),
    // I guess it's possible to do the transformation with zod
    // not sure it's preferable, maybe a readability issue
    // since more people will know js/ts than zod
    /*
        z
        .string()
        .transform((val) => val.trim())
        .pipe(
            z.string()
                .transform((val) =>
                    val ? val.split(',').map((u) => u.trim()).filter(Boolean) : []
                )
                .pipe(
                    z.array(
                        z.string()
                            .min(1)
                            .max(15)
                            .regex(
                                /^[A-Za-z][A-Za-z0-9_]*[A-Za-z0-9]$|^[A-Za-z]$/,
                                'Invalid Twitter username format'
                            )
                    )
                )
                .transform((users) => users.join(','))
        )
        .optional()
        .default(''),
    */
    ENABLE_TWITTER_POST_GENERATION: z.boolean(),
    POST_INTERVAL_MIN: z.number().int(),
    POST_INTERVAL_MAX: z.number().int(),
    ENABLE_ACTION_PROCESSING: z.boolean(),
    ACTION_INTERVAL: z.number().int(),
    POST_IMMEDIATELY: z.boolean(),
    TWITTER_SPACES_ENABLE: z.boolean().default(false),
    MAX_ACTIONS_PROCESSING: z.number().int(),
    ACTION_TIMELINE_TYPE: z
        .nativeEnum(ActionTimelineType)
        .default(ActionTimelineType.ForYou),
});

export type TwitterConfig = z.infer<typeof twitterEnvSchema>;

/**
 * Helper to parse a comma-separated list of Twitter usernames
 * (already present in your code).
 */
function parseTargetUsers(targetUsersStr?: string | null): string[] {
    if (!targetUsersStr?.trim()) {
        return [];
    }
    return targetUsersStr
        .split(",")
        .map((user) => user.trim())
        .filter(Boolean);
}

function safeParseInt(
    value: string | undefined | null,
    defaultValue: number
): number {
    if (!value) return defaultValue;
    const parsed = Number.parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : Math.max(1, parsed);
}

/**
 * Validates or constructs a TwitterConfig object using zod,
 * taking values from the IAgentRuntime or process.env as needed.
 */
// This also is organized to serve as a point of documentation for the client
// most of the inputs from the framework (env/character)

// we also do a lot of typing/parsing here
// so we can do it once and only once per character
export async function validateTwitterConfig(
    runtime: IAgentRuntime
): Promise<TwitterConfig> {
    try {
        const twitterConfig = {
            TWITTER_DRY_RUN:
                parseBooleanFromText(
                    runtime.getSetting("TWITTER_DRY_RUN") ||
                        process.env.TWITTER_DRY_RUN
                ) ?? false, // parseBooleanFromText return null if "", map "" to false

            TWITTER_USERNAME:
                runtime.getSetting("TWITTER_USERNAME") ||
                process.env.TWITTER_USERNAME,

            TWITTER_PASSWORD:
                runtime.getSetting("TWITTER_PASSWORD") ||
                process.env.TWITTER_PASSWORD,

            TWITTER_EMAIL:
                runtime.getSetting("TWITTER_EMAIL") ||
                process.env.TWITTER_EMAIL,

            // number as string?
            MAX_TWEET_LENGTH: safeParseInt(
                runtime.getSetting("MAX_TWEET_LENGTH") ||
                    process.env.MAX_TWEET_LENGTH,
                DEFAULT_MAX_TWEET_LENGTH
            ),

            TWITTER_SEARCH_ENABLE:
                parseBooleanFromText(
                    runtime.getSetting("TWITTER_SEARCH_ENABLE") ||
                        process.env.TWITTER_SEARCH_ENABLE
                ) ?? false,

            // string passthru
            TWITTER_2FA_SECRET:
                runtime.getSetting("TWITTER_2FA_SECRET") ||
                process.env.TWITTER_2FA_SECRET ||
                "",

            // int
            TWITTER_RETRY_LIMIT: safeParseInt(
                runtime.getSetting("TWITTER_RETRY_LIMIT") ||
                    process.env.TWITTER_RETRY_LIMIT,
                5
            ),

            // int in seconds
            TWITTER_POLL_INTERVAL: safeParseInt(
                runtime.getSetting("TWITTER_POLL_INTERVAL") ||
                    process.env.TWITTER_POLL_INTERVAL,
                120 // 2m
            ),

            // comma separated string
            TWITTER_TARGET_USERS: parseTargetUsers(
                runtime.getSetting("TWITTER_TARGET_USERS") ||
                    process.env.TWITTER_TARGET_USERS
            ),

            // bool
            ENABLE_TWITTER_POST_GENERATION:
                parseBooleanFromText(
                    runtime.getSetting("ENABLE_TWITTER_POST_GENERATION") ||
                        process.env.ENABLE_TWITTER_POST_GENERATION
                ) ?? true,


            // int in minutes
            POST_INTERVAL_MIN: safeParseInt(
                runtime.getSetting("POST_INTERVAL_MIN") ||
                    process.env.POST_INTERVAL_MIN,
                90 // 1.5 hours
            ),

            // int in minutes
            POST_INTERVAL_MAX: safeParseInt(
                runtime.getSetting("POST_INTERVAL_MAX") ||
                    process.env.POST_INTERVAL_MAX,
                180 // 3 hours
            ),

            // bool
            ENABLE_ACTION_PROCESSING:
                parseBooleanFromText(
                    runtime.getSetting("ENABLE_ACTION_PROCESSING") ||
                        process.env.ENABLE_ACTION_PROCESSING
                ) ?? false,

            // init in minutes (min 1m)
            ACTION_INTERVAL: safeParseInt(
                runtime.getSetting("ACTION_INTERVAL") ||
                    process.env.ACTION_INTERVAL,
                5 // 5 minutes
            ),

            // bool
            POST_IMMEDIATELY:
                parseBooleanFromText(
                    runtime.getSetting("POST_IMMEDIATELY") ||
                        process.env.POST_IMMEDIATELY
                ) ?? false,

            TWITTER_SPACES_ENABLE:
                parseBooleanFromText(
                    runtime.getSetting("TWITTER_SPACES_ENABLE") ||
                        process.env.TWITTER_SPACES_ENABLE
                ) ?? false,

            MAX_ACTIONS_PROCESSING: safeParseInt(
                runtime.getSetting("MAX_ACTIONS_PROCESSING") ||
                    process.env.MAX_ACTIONS_PROCESSING,
                1
            ),

            ACTION_TIMELINE_TYPE:
                runtime.getSetting("ACTION_TIMELINE_TYPE") ||
                process.env.ACTION_TIMELINE_TYPE,
        };

        return twitterEnvSchema.parse(twitterConfig);
    } catch (error) {
        if (error instanceof ZodError) {
            const errorMessages = error.errors
                .map((err) => `${err.path.join(".")}: ${err.message}`)
                .join("\n");
            throw new Error(
                `X/Twitter configuration validation failed:\n${errorMessages}`
            );
        }
        throw error;
    }
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/utils.ts`:

```ts
import type { Tweet } from "agent-twitter-client";
import { getEmbeddingZeroVector } from "@elizaos/core";
import type { Content, Memory, UUID } from "@elizaos/core";
import { stringToUuid } from "@elizaos/core";
import type { ClientBase } from "./base";
import { elizaLogger } from "@elizaos/core";
import type { Media } from "@elizaos/core";
import fs from "fs";
import path from "path";
import { MediaData } from "./types";

export const wait = (minTime = 1000, maxTime = 3000) => {
    const waitTime =
        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;
    return new Promise((resolve) => setTimeout(resolve, waitTime));
};

export const isValidTweet = (tweet: Tweet): boolean => {
    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage
    const hashtagCount = (tweet.text?.match(/#/g) || []).length;
    const atCount = (tweet.text?.match(/@/g) || []).length;
    const dollarSignCount = (tweet.text?.match(/\$/g) || []).length;
    const totalCount = hashtagCount + atCount + dollarSignCount;

    return (
        hashtagCount <= 1 &&
        atCount <= 2 &&
        dollarSignCount <= 1 &&
        totalCount <= 3
    );
};

export async function buildConversationThread(
    tweet: Tweet,
    client: ClientBase,
    maxReplies = 10
): Promise<Tweet[]> {
    const thread: Tweet[] = [];
    const visited: Set<string> = new Set();

    async function processThread(currentTweet: Tweet, depth = 0) {
        elizaLogger.debug("Processing tweet:", {
            id: currentTweet.id,
            inReplyToStatusId: currentTweet.inReplyToStatusId,
            depth: depth,
        });

        if (!currentTweet) {
            elizaLogger.debug("No current tweet found for thread building");
            return;
        }

        // Stop if we've reached our reply limit
        if (depth >= maxReplies) {
            elizaLogger.debug("Reached maximum reply depth", depth);
            return;
        }

        // Handle memory storage
        const memory = await client.runtime.messageManager.getMemoryById(
            stringToUuid(currentTweet.id + "-" + client.runtime.agentId)
        );
        if (!memory) {
            const roomId = stringToUuid(
                currentTweet.conversationId + "-" + client.runtime.agentId
            );
            const userId = stringToUuid(currentTweet.userId);

            await client.runtime.ensureConnection(
                userId,
                roomId,
                currentTweet.username,
                currentTweet.name,
                "twitter"
            );

            await client.runtime.messageManager.createMemory({
                id: stringToUuid(
                    currentTweet.id + "-" + client.runtime.agentId
                ),
                agentId: client.runtime.agentId,
                content: {
                    text: currentTweet.text,
                    source: "twitter",
                    url: currentTweet.permanentUrl,
                    imageUrls: currentTweet.photos.map((p) => p.url) || [],
                    inReplyTo: currentTweet.inReplyToStatusId
                        ? stringToUuid(
                              currentTweet.inReplyToStatusId +
                                  "-" +
                                  client.runtime.agentId
                          )
                        : undefined,
                },
                createdAt: currentTweet.timestamp * 1000,
                roomId,
                userId:
                    currentTweet.userId === client.profile.id
                        ? client.runtime.agentId
                        : stringToUuid(currentTweet.userId),
                embedding: getEmbeddingZeroVector(),
            });
        }

        if (visited.has(currentTweet.id)) {
            elizaLogger.debug("Already visited tweet:", currentTweet.id);
            return;
        }

        visited.add(currentTweet.id);
        thread.unshift(currentTweet);

        elizaLogger.debug("Current thread state:", {
            length: thread.length,
            currentDepth: depth,
            tweetId: currentTweet.id,
        });

        // If there's a parent tweet, fetch and process it
        if (currentTweet.inReplyToStatusId) {
            elizaLogger.debug(
                "Fetching parent tweet:",
                currentTweet.inReplyToStatusId
            );
            try {
                const parentTweet = await client.twitterClient.getTweet(
                    currentTweet.inReplyToStatusId
                );

                if (parentTweet) {
                    elizaLogger.debug("Found parent tweet:", {
                        id: parentTweet.id,
                        text: parentTweet.text?.slice(0, 50),
                    });
                    await processThread(parentTweet, depth + 1);
                } else {
                    elizaLogger.debug(
                        "No parent tweet found for:",
                        currentTweet.inReplyToStatusId
                    );
                }
            } catch (error) {
                elizaLogger.error("Error fetching parent tweet:", {
                    tweetId: currentTweet.inReplyToStatusId,
                    error,
                });
            }
        } else {
            elizaLogger.debug(
                "Reached end of reply chain at:",
                currentTweet.id
            );
        }
    }

    await processThread(tweet, 0);

    elizaLogger.debug("Final thread built:", {
        totalTweets: thread.length,
        tweetIds: thread.map((t) => ({
            id: t.id,
            text: t.text?.slice(0, 50),
        })),
    });

    return thread;
}

export async function fetchMediaData(
    attachments: Media[]
): Promise<MediaData[]> {
    return Promise.all(
        attachments.map(async (attachment: Media) => {
            if (/^(http|https):\/\//.test(attachment.url)) {
                // Handle HTTP URLs
                const response = await fetch(attachment.url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch file: ${attachment.url}`);
                }
                const mediaBuffer = Buffer.from(await response.arrayBuffer());
                const mediaType = attachment.contentType;
                return { data: mediaBuffer, mediaType };
            } else if (fs.existsSync(attachment.url)) {
                // Handle local file paths
                const mediaBuffer = await fs.promises.readFile(
                    path.resolve(attachment.url)
                );
                const mediaType = attachment.contentType;
                return { data: mediaBuffer, mediaType };
            } else {
                throw new Error(
                    `File not found: ${attachment.url}. Make sure the path is correct.`
                );
            }
        })
    );
}

export async function sendTweet(
    client: ClientBase,
    content: Content,
    roomId: UUID,
    twitterUsername: string,
    inReplyTo: string
): Promise<Memory[]> {
    const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;
    const isLongTweet = maxTweetLength > 280;

    const tweetChunks = splitTweetContent(content.text, maxTweetLength);
    const sentTweets: Tweet[] = [];
    let previousTweetId = inReplyTo;

    for (const chunk of tweetChunks) {
        let mediaData = null;

        if (content.attachments && content.attachments.length > 0) {
            mediaData = await fetchMediaData(content.attachments);
        }

        const cleanChunk = deduplicateMentions(chunk.trim())

        const result = await client.requestQueue.add(async () =>
            isLongTweet
                ? client.twitterClient.sendLongTweet(
                      cleanChunk,
                      previousTweetId,
                      mediaData
                  )
                : client.twitterClient.sendTweet(
                      cleanChunk,
                      previousTweetId,
                      mediaData
                  )
        );

        const body = await result.json();
        const tweetResult = isLongTweet
            ? body?.data?.notetweet_create?.tweet_results?.result
            : body?.data?.create_tweet?.tweet_results?.result;

        // if we have a response
        if (tweetResult) {
            // Parse the response
            const finalTweet: Tweet = {
                id: tweetResult.rest_id,
                text: tweetResult.legacy.full_text,
                conversationId: tweetResult.legacy.conversation_id_str,
                timestamp:
                    new Date(tweetResult.legacy.created_at).getTime() / 1000,
                userId: tweetResult.legacy.user_id_str,
                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,
                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,
                hashtags: [],
                mentions: [],
                photos: [],
                thread: [],
                urls: [],
                videos: [],
            };
            sentTweets.push(finalTweet);
            previousTweetId = finalTweet.id;
        } else {
            elizaLogger.error("Error sending tweet chunk:", {
                chunk,
                response: body,
            });
        }

        // Wait a bit between tweets to avoid rate limiting issues
        await wait(1000, 2000);
    }

    const memories: Memory[] = sentTweets.map((tweet) => ({
        id: stringToUuid(tweet.id + "-" + client.runtime.agentId),
        agentId: client.runtime.agentId,
        userId: client.runtime.agentId,
        content: {
            tweetId: tweet.id,
            text: tweet.text,
            source: "twitter",
            url: tweet.permanentUrl,
            imageUrls: tweet.photos.map((p) => p.url) || [],
            inReplyTo: tweet.inReplyToStatusId
                ? stringToUuid(
                      tweet.inReplyToStatusId + "-" + client.runtime.agentId
                  )
                : undefined,
        },
        roomId,
        embedding: getEmbeddingZeroVector(),
        createdAt: tweet.timestamp * 1000, 
    }));

    return memories;
}

function splitTweetContent(content: string, maxLength: number): string[] {
    const paragraphs = content.split("\n\n").map((p) => p.trim());
    const tweets: string[] = [];
    let currentTweet = "";

    for (const paragraph of paragraphs) {
        if (!paragraph) continue;

        if ((currentTweet + "\n\n" + paragraph).trim().length <= maxLength) {
            if (currentTweet) {
                currentTweet += "\n\n" + paragraph;
            } else {
                currentTweet = paragraph;
            }
        } else {
            if (currentTweet) {
                tweets.push(currentTweet.trim());
            }
            if (paragraph.length <= maxLength) {
                currentTweet = paragraph;
            } else {
                // Split long paragraph into smaller chunks
                const chunks = splitParagraph(paragraph, maxLength);
                tweets.push(...chunks.slice(0, -1));
                currentTweet = chunks[chunks.length - 1];
            }
        }
    }

    if (currentTweet) {
        tweets.push(currentTweet.trim());
    }

    return tweets;
}

function extractUrls(paragraph: string): {
    textWithPlaceholders: string;
    placeholderMap: Map<string, string>;
} {
    // replace https urls with placeholder
    const urlRegex = /https?:\/\/[^\s]+/g;
    const placeholderMap = new Map<string, string>();

    let urlIndex = 0;
    const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {
        // twitter url would be considered as 23 characters
        // <<URL_CONSIDERER_23_1>> is also 23 characters
        const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc
        placeholderMap.set(placeholder, match);
        urlIndex++;
        return placeholder;
    });

    return { textWithPlaceholders, placeholderMap };
}

function splitSentencesAndWords(text: string, maxLength: number): string[] {
    // Split by periods, question marks and exclamation marks
    // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots
    const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];
    const chunks: string[] = [];
    let currentChunk = "";

    for (const sentence of sentences) {
        if ((currentChunk + " " + sentence).trim().length <= maxLength) {
            if (currentChunk) {
                currentChunk += " " + sentence;
            } else {
                currentChunk = sentence;
            }
        } else {
            // Can't fit more, push currentChunk to results
            if (currentChunk) {
                chunks.push(currentChunk.trim());
            }

            // If current sentence itself is less than or equal to maxLength
            if (sentence.length <= maxLength) {
                currentChunk = sentence;
            } else {
                // Need to split sentence by spaces
                const words = sentence.split(" ");
                currentChunk = "";
                for (const word of words) {
                    if (
                        (currentChunk + " " + word).trim().length <= maxLength
                    ) {
                        if (currentChunk) {
                            currentChunk += " " + word;
                        } else {
                            currentChunk = word;
                        }
                    } else {
                        if (currentChunk) {
                            chunks.push(currentChunk.trim());
                        }
                        currentChunk = word;
                    }
                }
            }
        }
    }

    // Handle remaining content
    if (currentChunk) {
        chunks.push(currentChunk.trim());
    }

    return chunks;
}

function deduplicateMentions(paragraph: string) {
    // Regex to match mentions at the beginning of the string
  const mentionRegex = /^@(\w+)(?:\s+@(\w+))*(\s+|$)/;

  // Find all matches
  const matches = paragraph.match(mentionRegex);

  if (!matches) {
    return paragraph; // If no matches, return the original string
  }

  // Extract mentions from the match groups
  let mentions = matches.slice(0, 1)[0].trim().split(' ')

  // Deduplicate mentions
  mentions = [...new Set(mentions)];

  // Reconstruct the string with deduplicated mentions
  const uniqueMentionsString = mentions.join(' ');

  // Find where the mentions end in the original string
  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;

  // Construct the result by combining unique mentions with the rest of the string
  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);
}

function restoreUrls(
    chunks: string[],
    placeholderMap: Map<string, string>
): string[] {
    return chunks.map((chunk) => {
        // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex
        return chunk.replace(/<<URL_CONSIDERER_23_(\d+)>>/g, (match) => {
            const original = placeholderMap.get(match);
            return original || match; // Return placeholder if not found (theoretically won't happen)
        });
    });
}

function splitParagraph(paragraph: string, maxLength: number): string[] {
    // 1) Extract URLs and replace with placeholders
    const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);

    // 2) Use first section's logic to split by sentences first, then do secondary split
    const splittedChunks = splitSentencesAndWords(
        textWithPlaceholders,
        maxLength
    );

    // 3) Replace placeholders back to original URLs
    const restoredChunks = restoreUrls(splittedChunks, placeholderMap);

    return restoredChunks;
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/types.ts`:

```ts
export type MediaData = {
    data: Buffer;
    mediaType: string;
};

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/spaces.ts`:

```ts
import {
    elizaLogger,
    type IAgentRuntime,
    composeContext,
    generateText,
    ModelClass,
    ServiceType,
    type ITranscriptionService,
    type TwitterSpaceDecisionOptions,
} from "@elizaos/core";
import type { ClientBase } from "./base";
import {
    type Scraper,
    Space,
    type SpaceConfig,
    RecordToDiskPlugin,
    IdleMonitorPlugin,
    type SpeakerRequest,
} from "agent-twitter-client";
import { SttTtsPlugin } from "./plugins/SttTtsSpacesPlugin.ts";

interface CurrentSpeakerState {
    userId: string;
    sessionUUID: string;
    username: string;
    startTime: number;
}

/**
 * Generate short filler text via GPT
 */
async function generateFiller(
    runtime: IAgentRuntime,
    fillerType: string
): Promise<string> {
    try {
        const context = composeContext({
            state: { fillerType },
            template: `
# INSTRUCTIONS:
You are generating a short filler message for a Twitter Space. The filler type is "{{fillerType}}".
Keep it brief, friendly, and relevant. No more than two sentences.
Only return the text, no additional formatting.

---
`,
        });
        const output = await generateText({
            runtime,
            context,
            modelClass: ModelClass.SMALL,
        });
        return output.trim();
    } catch (err) {
        elizaLogger.error("[generateFiller] Error generating filler:", err);
        return "";
    }
}

/**
 * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.
 */
async function speakFiller(
    runtime: IAgentRuntime,
    sttTtsPlugin: SttTtsPlugin | undefined,
    fillerType: string,
    sleepAfterMs = 3000
): Promise<void> {
    if (!sttTtsPlugin) return;
    const text = await generateFiller(runtime, fillerType);
    if (!text) return;

    elizaLogger.log(`[Space] Filler (${fillerType}) => ${text}`);
    await sttTtsPlugin.speakText(text);

    if (sleepAfterMs > 0) {
        await new Promise((res) => setTimeout(res, sleepAfterMs));
    }
}

/**
 * Generate topic suggestions via GPT if no topics are configured
 */
async function generateTopicsIfEmpty(
    runtime: IAgentRuntime
): Promise<string[]> {
    try {
        const context = composeContext({
            state: {},
            template: `
# INSTRUCTIONS:
Please generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.
Return them as a comma-separated list, no additional formatting or numbering.

Example:
"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics"
---
`,
        });
        const response = await generateText({
            runtime,
            context,
            modelClass: ModelClass.SMALL,
        });
        const topics = response
            .split(",")
            .map((t) => t.trim())
            .filter(Boolean);
        return topics.length ? topics : ["Random Tech Chat", "AI Thoughts"];
    } catch (err) {
        elizaLogger.error("[generateTopicsIfEmpty] GPT error =>", err);
        return ["Random Tech Chat", "AI Thoughts"];
    }
}

/**
 * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.
 */
export class TwitterSpaceClient {
    private runtime: IAgentRuntime;
    private client: ClientBase;
    private scraper: Scraper;
    private isSpaceRunning = false;
    private currentSpace?: Space;
    private spaceId?: string;
    private startedAt?: number;
    private checkInterval?: NodeJS.Timeout;
    private lastSpaceEndedAt?: number;
    private sttTtsPlugin?: SttTtsPlugin;

    /**
     * We now store an array of active speakers, not just 1
     */
    private activeSpeakers: CurrentSpeakerState[] = [];
    private speakerQueue: SpeakerRequest[] = [];

    private decisionOptions: TwitterSpaceDecisionOptions;

    constructor(client: ClientBase, runtime: IAgentRuntime) {
        this.client = client;
        this.scraper = client.twitterClient;
        this.runtime = runtime;

        const charSpaces = runtime.character.twitterSpaces || {};
        this.decisionOptions = {
            maxSpeakers: charSpaces.maxSpeakers ?? 1,
            topics: charSpaces.topics ?? [],
            typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,
            idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,
            minIntervalBetweenSpacesMinutes:
                charSpaces.minIntervalBetweenSpacesMinutes ?? 60,
            businessHoursOnly: charSpaces.businessHoursOnly ?? false,
            randomChance: charSpaces.randomChance ?? 0.3,
            enableIdleMonitor: charSpaces.enableIdleMonitor !== false,
            enableSttTts: charSpaces.enableSttTts !== false,
            enableRecording: charSpaces.enableRecording !== false,
            voiceId:
                charSpaces.voiceId ||
                runtime.character.settings.voice.model ||
                "Xb7hH8MSUJpSbSDYk0k2",
            sttLanguage: charSpaces.sttLanguage || "en",
            speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,
        };
    }

    /**
     * Periodic check to launch or manage space
     */
    public async startPeriodicSpaceCheck() {
        elizaLogger.log("[Space] Starting periodic check routine...");

        // For instance:
        const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running
        const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running

        const routine = async () => {
            try {
                if (!this.isSpaceRunning) {
                    // Space not running => check if we should launch
                    const launch = await this.shouldLaunchSpace();
                    if (launch) {
                        const config = await this.generateSpaceConfig();
                        await this.startSpace(config);
                    }
                    // Plan next iteration with a slower pace
                    this.checkInterval = setTimeout(
                        routine,
                        this.isSpaceRunning
                            ? intervalMsWhenRunning
                            : intervalMsWhenIdle
                    );
                } else {
                    // Space is running => manage it more frequently
                    await this.manageCurrentSpace();
                    // Plan next iteration with a faster pace
                    this.checkInterval = setTimeout(
                        routine,
                        intervalMsWhenRunning
                    );
                }
            } catch (error) {
                elizaLogger.error("[Space] Error in routine =>", error);
                // In case of error, still schedule next iteration
                this.checkInterval = setTimeout(routine, intervalMsWhenIdle);
            }
        };

        routine();
    }

    stopPeriodicCheck() {
        if (this.checkInterval) {
            clearTimeout(this.checkInterval);
            this.checkInterval = undefined;
        }
    }

    private async shouldLaunchSpace(): Promise<boolean> {
        // Random chance
        const r = Math.random();
        if (r > (this.decisionOptions.randomChance ?? 0.3)) {
            elizaLogger.log("[Space] Random check => skip launching");
            return false;
        }
        // Business hours
        if (this.decisionOptions.businessHoursOnly) {
            const hour = new Date().getUTCHours();
            if (hour < 9 || hour >= 17) {
                elizaLogger.log("[Space] Out of business hours => skip");
                return false;
            }
        }
        // Interval
        const now = Date.now();
        if (this.lastSpaceEndedAt) {
            const minIntervalMs =
                (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) *
                60_000;
            if (now - this.lastSpaceEndedAt < minIntervalMs) {
                elizaLogger.log("[Space] Too soon since last space => skip");
                return false;
            }
        }

        elizaLogger.log("[Space] Deciding to launch a new Space...");
        return true;
    }

    private async generateSpaceConfig(): Promise<SpaceConfig> {
        if (
            !this.decisionOptions.topics ||
            this.decisionOptions.topics.length === 0
        ) {
            const newTopics = await generateTopicsIfEmpty(this.client.runtime);
            this.decisionOptions.topics = newTopics;
        }

        let chosenTopic = "Random Tech Chat";
        if (
            this.decisionOptions.topics &&
            this.decisionOptions.topics.length > 0
        ) {
            chosenTopic =
                this.decisionOptions.topics[
                    Math.floor(
                        Math.random() * this.decisionOptions.topics.length
                    )
                ];
        }

        return {
            mode: "INTERACTIVE",
            title: chosenTopic,
            description: `Discussion about ${chosenTopic}`,
            languages: ["en"],
        };
    }

    public async startSpace(config: SpaceConfig) {
        elizaLogger.log("[Space] Starting a new Twitter Space...");

        try {
            this.currentSpace = new Space(this.scraper);
            this.isSpaceRunning = false;
            this.spaceId = undefined;
            this.startedAt = Date.now();

            // Reset states
            this.activeSpeakers = [];
            this.speakerQueue = [];

            // Retrieve keys
            const elevenLabsKey =
                this.runtime.getSetting("ELEVENLABS_XI_API_KEY") || "";

            const broadcastInfo = await this.currentSpace.initialize(config);
            this.spaceId = broadcastInfo.room_id;
            // Plugins
            if (this.decisionOptions.enableRecording) {
                elizaLogger.log("[Space] Using RecordToDiskPlugin");
                this.currentSpace.use(new RecordToDiskPlugin());
            }

            if (this.decisionOptions.enableSttTts) {
                elizaLogger.log("[Space] Using SttTtsPlugin");
                const sttTts = new SttTtsPlugin();
                this.sttTtsPlugin = sttTts;
                this.currentSpace.use(sttTts, {
                    runtime: this.runtime,
                    client: this.client,
                    spaceId: this.spaceId,
                    elevenLabsApiKey: elevenLabsKey,
                    voiceId: this.decisionOptions.voiceId,
                    sttLanguage: this.decisionOptions.sttLanguage,
                    transcriptionService:
                        this.client.runtime.getService<ITranscriptionService>(
                            ServiceType.TRANSCRIPTION
                        ),
                });
            }

            if (this.decisionOptions.enableIdleMonitor) {
                elizaLogger.log("[Space] Using IdleMonitorPlugin");
                this.currentSpace.use(
                    new IdleMonitorPlugin(
                        this.decisionOptions.idleKickTimeoutMs ?? 60_000,
                        10_000
                    )
                );
            }

            this.isSpaceRunning = true;
            await this.scraper.sendTweet(
                broadcastInfo.share_url.replace("broadcasts", "spaces")
            );

            const spaceUrl = broadcastInfo.share_url.replace(
                "broadcasts",
                "spaces"
            );
            elizaLogger.log(`[Space] Space started => ${spaceUrl}`);

            // Greet
            await speakFiller(
                this.client.runtime,
                this.sttTtsPlugin,
                "WELCOME"
            );

            // Events
            this.currentSpace.on("occupancyUpdate", (update) => {
                elizaLogger.log(
                    `[Space] Occupancy => ${update.occupancy} participant(s).`
                );
            });

            this.currentSpace.on(
                "speakerRequest",
                async (req: SpeakerRequest) => {
                    elizaLogger.log(
                        `[Space] Speaker request from @${req.username} (${req.userId}).`
                    );
                    await this.handleSpeakerRequest(req);
                }
            );

            this.currentSpace.on("idleTimeout", async (info) => {
                elizaLogger.log(
                    `[Space] idleTimeout => no audio for ${info.idleMs} ms.`
                );
                await speakFiller(
                    this.client.runtime,
                    this.sttTtsPlugin,
                    "IDLE_ENDING"
                );
                await this.stopSpace();
            });

            process.on("SIGINT", async () => {
                elizaLogger.log("[Space] SIGINT => stopping space");
                await speakFiller(
                    this.client.runtime,
                    this.sttTtsPlugin,
                    "CLOSING"
                );
                await this.stopSpace();
                process.exit(0);
            });
        } catch (error) {
            elizaLogger.error("[Space] Error launching Space =>", error);
            this.isSpaceRunning = false;
            throw error;
        }
    }

    /**
     * Periodic management: check durations, remove extras, maybe accept new from queue
     */
    private async manageCurrentSpace() {
        if (!this.spaceId || !this.currentSpace) return;
        try {
            const audioSpace = await this.scraper.getAudioSpaceById(
                this.spaceId
            );
            const { participants } = audioSpace;
            const numSpeakers = participants.speakers?.length || 0;
            const totalListeners = participants.listeners?.length || 0;

            // 1) Remove any speaker who exceeded speakerMaxDurationMs
            const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;
            const now = Date.now();

            for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {
                const speaker = this.activeSpeakers[i];
                const elapsed = now - speaker.startTime;
                if (elapsed > maxDur) {
                    elizaLogger.log(
                        `[Space] Speaker @${speaker.username} exceeded max duration => removing`
                    );
                    await this.removeSpeaker(speaker.userId);
                    this.activeSpeakers.splice(i, 1);

                    // Possibly speak a short "SPEAKER_LEFT" filler
                    await speakFiller(
                        this.client.runtime,
                        this.sttTtsPlugin,
                        "SPEAKER_LEFT"
                    );
                }
            }

            // 2) If we have capacity for new speakers from the queue, accept them
            await this.acceptSpeakersFromQueueIfNeeded();

            // 3) If somehow more than maxSpeakers are active, remove the extras
            if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {
                elizaLogger.log(
                    "[Space] More than maxSpeakers => removing extras..."
                );
                await this.kickExtraSpeakers(participants.speakers);
            }

            // 4) Possibly stop the space if empty or time exceeded
            const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;
            if (
                elapsedMinutes >
                    (this.decisionOptions.typicalDurationMinutes ?? 30) ||
                (numSpeakers === 0 &&
                    totalListeners === 0 &&
                    elapsedMinutes > 5)
            ) {
                elizaLogger.log(
                    "[Space] Condition met => stopping the Space..."
                );
                await speakFiller(
                    this.client.runtime,
                    this.sttTtsPlugin,
                    "CLOSING",
                    4000
                );
                await this.stopSpace();
            }
        } catch (error) {
            elizaLogger.error("[Space] Error in manageCurrentSpace =>", error);
        }
    }

    /**
     * If we have available slots, accept new speakers from the queue
     */
    private async acceptSpeakersFromQueueIfNeeded() {
        // while queue not empty and activeSpeakers < maxSpeakers, accept next
        const ms = this.decisionOptions.maxSpeakers ?? 1;
        while (
            this.speakerQueue.length > 0 &&
            this.activeSpeakers.length < ms
        ) {
            const nextReq = this.speakerQueue.shift();
            if (nextReq) {
                await speakFiller(
                    this.client.runtime,
                    this.sttTtsPlugin,
                    "PRE_ACCEPT"
                );
                await this.acceptSpeaker(nextReq);
            }
        }
    }

    private async handleSpeakerRequest(req: SpeakerRequest) {
        if (!this.spaceId || !this.currentSpace) return;

        const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);
        const janusSpeakers = audioSpace?.participants?.speakers || [];

        // If we haven't reached maxSpeakers, accept immediately
        if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {
            elizaLogger.log(`[Space] Accepting speaker @${req.username} now`);
            await speakFiller(
                this.client.runtime,
                this.sttTtsPlugin,
                "PRE_ACCEPT"
            );
            await this.acceptSpeaker(req);
        } else {
            elizaLogger.log(
                `[Space] Adding speaker @${req.username} to the queue`
            );
            this.speakerQueue.push(req);
        }
    }

    private async acceptSpeaker(req: SpeakerRequest) {
        if (!this.currentSpace) return;
        try {
            await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);
            this.activeSpeakers.push({
                userId: req.userId,
                sessionUUID: req.sessionUUID,
                username: req.username,
                startTime: Date.now(),
            });
            elizaLogger.log(`[Space] Speaker @${req.username} is now live`);
        } catch (err) {
            elizaLogger.error(
                `[Space] Error approving speaker @${req.username}:`,
                err
            );
        }
    }

    private async removeSpeaker(userId: string) {
        if (!this.currentSpace) return;
        try {
            await this.currentSpace.removeSpeaker(userId);
            elizaLogger.log(`[Space] Removed speaker userId=${userId}`);
        } catch (error) {
            elizaLogger.error(
                `[Space] Error removing speaker userId=${userId} =>`,
                error
            );
        }
    }

    /**
     * If more than maxSpeakers are found, remove extras
     * Also update activeSpeakers array
     */
    private async kickExtraSpeakers(speakers: any[]) {
        if (!this.currentSpace) return;
        const ms = this.decisionOptions.maxSpeakers ?? 1;

        // sort by who joined first if needed, or just slice
        const extras = speakers.slice(ms);
        for (const sp of extras) {
            elizaLogger.log(
                `[Space] Removing extra speaker => userId=${sp.user_id}`
            );
            await this.removeSpeaker(sp.user_id);

            // remove from activeSpeakers array
            const idx = this.activeSpeakers.findIndex(
                (s) => s.userId === sp.user_id
            );
            if (idx !== -1) {
                this.activeSpeakers.splice(idx, 1);
            }
        }
    }

    public async stopSpace() {
        if (!this.currentSpace || !this.isSpaceRunning) return;
        try {
            elizaLogger.log("[Space] Stopping the current Space...");
            await this.currentSpace.stop();
        } catch (err) {
            elizaLogger.error("[Space] Error stopping Space =>", err);
        } finally {
            this.isSpaceRunning = false;
            this.spaceId = undefined;
            this.currentSpace = undefined;
            this.startedAt = undefined;
            this.lastSpaceEndedAt = Date.now();
            this.activeSpeakers = [];
            this.speakerQueue = [];
        }
    }
}

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/__tests__/environment.test.ts`:

```ts
import { twitterEnvSchema } from "../environment";

describe("Twitter Environment Configuration", () => {
    describe("Username Validation", () => {
        const validateUsername = (username: string) => {
            return twitterEnvSchema.parse({
                TWITTER_DRY_RUN: false,
                TWITTER_USERNAME: "test_user",
                TWITTER_PASSWORD: "password",
                TWITTER_EMAIL: "test@example.com",
                TWITTER_2FA_SECRET: "",
                TWITTER_RETRY_LIMIT: 5,
                TWITTER_POLL_INTERVAL: 120,
                POST_INTERVAL_MIN: 90,
                POST_INTERVAL_MAX: 180,
                ENABLE_ACTION_PROCESSING: false,
                ACTION_INTERVAL: 5,
                POST_IMMEDIATELY: false,
                TWITTER_TARGET_USERS: [username],
            });
        };

        it("should allow valid traditional usernames", () => {
            expect(() => validateUsername("normal_user")).not.toThrow();
            expect(() => validateUsername("user123")).not.toThrow();
            expect(() => validateUsername("a_1_b_2")).not.toThrow();
        });

        it("should allow usernames starting with digits", () => {
            expect(() => validateUsername("123user")).not.toThrow();
            expect(() => validateUsername("42_test")).not.toThrow();
            expect(() => validateUsername("007james")).not.toThrow();
        });

        it("should allow wildcard", () => {
            expect(() => validateUsername("*")).not.toThrow();
        });

        it("should reject invalid usernames", () => {
            expect(() => validateUsername("")).toThrow();
            expect(() => validateUsername("user@123")).toThrow();
            expect(() => validateUsername("user-123")).toThrow();
            expect(() => validateUsername("user.123")).toThrow();
            expect(() => validateUsername("a".repeat(16))).toThrow();
        });

        it("should handle array of usernames", () => {
            const config = {
                TWITTER_DRY_RUN: false,
                TWITTER_USERNAME: "test_user",
                TWITTER_PASSWORD: "password",
                TWITTER_EMAIL: "test@example.com",
                TWITTER_2FA_SECRET: "",
                TWITTER_RETRY_LIMIT: 5,
                TWITTER_POLL_INTERVAL: 120,
                POST_INTERVAL_MIN: 90,
                POST_INTERVAL_MAX: 180,
                ENABLE_ACTION_PROCESSING: false,
                ACTION_INTERVAL: 5,
                POST_IMMEDIATELY: false,
                TWITTER_TARGET_USERS: ["normal_user", "123digit", "*"],
            };

            expect(() => twitterEnvSchema.parse(config)).not.toThrow();
        });
    });
});

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/client.ts`:

```ts
import { type Client, elizaLogger, type IAgentRuntime, type Plugin } from "@elizaos/core";
import { ClientBase } from "./base.ts";
import { validateTwitterConfig, type TwitterConfig } from "./environment.ts";
import { TwitterInteractionClient } from "./interactions.ts";
import { TwitterPostClient } from "./post.ts";
import { TwitterSearchClient } from "./search.ts";
import { TwitterSpaceClient } from "./spaces.ts";

/**
 * A manager that orchestrates all specialized Twitter logic:
 * - client: base operations (login, timeline caching, etc.)
 * - post: autonomous posting logic
 * - search: searching tweets / replying logic
 * - interaction: handling mentions, replies
 * - space: launching and managing Twitter Spaces (optional)
 */
class TwitterManager {
    client: ClientBase;
    post: TwitterPostClient;
    search: TwitterSearchClient;
    interaction: TwitterInteractionClient;
    space?: TwitterSpaceClient;

    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {
        // Pass twitterConfig to the base client
        this.client = new ClientBase(runtime, twitterConfig);

        // Posting logic
        this.post = new TwitterPostClient(this.client, runtime);

        // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)
        if (twitterConfig.TWITTER_SEARCH_ENABLE) {
            elizaLogger.warn("Twitter/X client running in a mode that:");
            elizaLogger.warn("1. violates consent of random users");
            elizaLogger.warn("2. burns your rate limit");
            elizaLogger.warn("3. can get your account banned");
            elizaLogger.warn("use at your own risk");
            this.search = new TwitterSearchClient(this.client, runtime);
        }

        // Mentions and interactions
        this.interaction = new TwitterInteractionClient(this.client, runtime);

        // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)
        if (twitterConfig.TWITTER_SPACES_ENABLE) {
            this.space = new TwitterSpaceClient(this.client, runtime);
        }
    }

    async stop() {
        elizaLogger.warn("Twitter client does not support stopping yet");
    }
}

export const TwitterClientInterface: Client = {
    name: 'twitter',
    async start(runtime: IAgentRuntime) {
        const twitterConfig: TwitterConfig =
            await validateTwitterConfig(runtime);

        elizaLogger.log("Twitter client started");

        const manager = new TwitterManager(runtime, twitterConfig);

        // Initialize login/session
        await manager.client.init();

        // Start the posting loop
        await manager.post.start();

        // Start the search logic if it exists
        if (manager.search) {
            await manager.search.start();
        }

        // Start interactions (mentions, replies)
        await manager.interaction.start();

        // If Spaces are enabled, start the periodic check
        if (manager.space) {
            manager.space.startPeriodicSpaceCheck();
        }

        return manager;
    },
};
```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/index.ts`:

```ts
import { TwitterClientInterface } from "./client";

const twitterPlugin = {
    name: "twitter",
    description: "Twitter client",
    clients: [TwitterClientInterface],
};
export default twitterPlugin;

```

`/Users/shawwalters/auto-upgrader/plugin-twitter/src/post.ts`:

```ts
import type { Tweet } from "agent-twitter-client";
import {
    composeContext,
    generateText,
    getEmbeddingZeroVector,
    type IAgentRuntime,
    ModelClass,
    stringToUuid,
    type TemplateType,
    type UUID,
    truncateToCompleteSentence,
    parseJSONObjectFromText,
    extractAttributes,
    cleanJsonResponse,
} from "@elizaos/core";
import { elizaLogger } from "@elizaos/core";
import type { ClientBase } from "./base.ts";
import { postActionResponseFooter } from "@elizaos/core";
import { generateTweetActions } from "@elizaos/core";
import { type IImageDescriptionService, ServiceType } from "@elizaos/core";
import { buildConversationThread, fetchMediaData } from "./utils.ts";
import { twitterMessageHandlerTemplate } from "./interactions.ts";
import { DEFAULT_MAX_TWEET_LENGTH } from "./environment.ts";
import {
    Client,
    Events,
    GatewayIntentBits,
    TextChannel,
    Partials,
} from "discord.js";
import type { State } from "@elizaos/core";
import type { ActionResponse } from "@elizaos/core";
import { MediaData } from "./types.ts";
import { v4 as uuidv4 } from 'uuid';
import type { Memory } from "@elizaos/core";

const MAX_TIMELINES_TO_FETCH = 15;

const twitterPostTemplate = `
# Areas of Expertise
{{knowledge}}

# About {{agentName}} (@{{twitterUserName}}):
{{bio}}
{{lore}}
{{topics}}

{{providers}}

{{characterPostExamples}}

{{postDirections}}

# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.
Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.`;

export const twitterActionTemplate =
    `
# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:
{{bio}}
{{postDirections}}

Guidelines:
- ONLY engage with content that DIRECTLY relates to character's core interests
- Direct mentions are priority IF they are on-topic
- Skip ALL content that is:
  - Off-topic or tangentially related
  - From high-profile accounts unless explicitly relevant
  - Generic/viral content without specific relevance
  - Political/controversial unless central to character
  - Promotional/marketing unless directly relevant

Actions (respond only with tags):
[LIKE] - Perfect topic match AND aligns with character (9.8/10)
[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)
[QUOTE] - Can add substantial domain expertise (9.5/10)
[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)

Tweet:
{{currentTweet}}

# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +
    postActionResponseFooter;

interface PendingTweet {
    tweetTextForPosting: string;
    roomId: UUID;
    rawTweetContent: string;
    taskId: string;
    timestamp: number;
}

type PendingTweetApprovalStatus = "PENDING" | "APPROVED" | "REJECTED";

export class TwitterPostClient {
    client: ClientBase;
    runtime: IAgentRuntime;
    twitterUsername: string;
    private isProcessing = false;
    private lastProcessTime = 0;
    private stopProcessingActions = false;
    private isDryRun: boolean;
    private discordClientForApproval: Client;
    private approvalRequired = false;
    private discordApprovalChannelId: string;
    private approvalCheckInterval: number;
    private raiinmakerService: any | null = null;
    private approvalProvider: string;

    constructor(client: ClientBase, runtime: IAgentRuntime) {
        elizaLogger.debug("🔍 TwitterPostClient constructor start");
        this.client = client;
        this.runtime = runtime;
        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;
        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;
        // Explicit debug for approval provider
        const rawApprovalProvider = process.env.TWITTER_APPROVAL_PROVIDER;
        elizaLogger.debug(`🔍 Raw approval provider from settings: "${rawApprovalProvider}"`);
        
        this.approvalProvider = rawApprovalProvider || "RAIINMAKER";
        elizaLogger.debug(`🔍 Final approval provider set to: "${this.approvalProvider}"`);
        
        // Log configuration on initialization
        elizaLogger.log("Twitter Client Configuration:");
        elizaLogger.log(`- Username: ${this.twitterUsername}`);
        elizaLogger.log(`- Dry Run Mode: ${this.isDryRun ? "enabled" : "disabled"}`);
        elizaLogger.log(`- Enable Post: ${this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION ? "enabled" : "disabled"}`);
        elizaLogger.log(`- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`);
        elizaLogger.log(`- Action Processing: ${this.client.twitterConfig.ENABLE_ACTION_PROCESSING ? "enabled" : "disabled"}`);
        elizaLogger.log(`- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`);
        elizaLogger.log(`- Post Immediately: ${this.client.twitterConfig.POST_IMMEDIATELY ? "enabled" : "disabled"}`);
        elizaLogger.log(`- Search Enabled: ${this.client.twitterConfig.TWITTER_SEARCH_ENABLE ? "enabled" : "disabled"}`);
        elizaLogger.log(`- Approval Provider: ${this.approvalProvider}`);
    
        const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;
        if (targetUsers) {
            elizaLogger.log(`- Target Users: ${targetUsers}`);
        }
    
        if (this.isDryRun) {
            elizaLogger.log("Twitter client initialized in dry run mode - no actual tweets will be posted");
        }
    
        // Initialize verification system
        const approvalEnabledSetting = this.runtime.getSetting("TWITTER_APPROVAL_ENABLED");
        elizaLogger.debug(`🔍 TWITTER_APPROVAL_ENABLED setting: "${approvalEnabledSetting}"`);
        
        const approvalRequired: boolean = approvalEnabledSetting?.toLowerCase() === "true";
        elizaLogger.debug(`🔍 Approval required: ${approvalRequired}`);
        
        if (approvalRequired) {
            elizaLogger.debug(`🔍 Setting this.approvalRequired = true`);
            this.approvalRequired = true;
            
            // Parse interval setting with fallback to 5 minutes (300000ms)
            const approvalCheckIntervalSetting = this.runtime.getSetting("TWITTER_APPROVAL_CHECK_INTERVAL");
            const APPROVAL_CHECK_INTERVAL = approvalCheckIntervalSetting 
                ? Number.parseInt(approvalCheckIntervalSetting) * 1000  // Convert seconds to milliseconds
                : 5 * 60 * 1000; // 5 minutes default
            
            this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;
            elizaLogger.log(`Twitter approval enabled using ${this.approvalProvider} verification with ${this.approvalCheckInterval/1000}s check interval`);

            elizaLogger.debug(`🔍 Checking provider - current provider: "${this.approvalProvider}"`);
            
            // Initialize only what's needed based on the provider
            if (this.approvalProvider === "RAIINMAKER") {
                elizaLogger.debug(`🔍 Entering Raiinmaker setup branch`);
                // Check if Raiinmaker plugin is available
                const raiinmakerEnabled = this.runtime.actions.some(
                    action => action.name === "VERIFY_GENERATION_CONTENT"
                );
                
                elizaLogger.debug(`🔍 Raiinmaker plugin available: ${raiinmakerEnabled}`);
                
                if (!raiinmakerEnabled) {
                    elizaLogger.warn("Twitter approval is set to use Raiinmaker but the plugin is not available");
                    elizaLogger.debug(`🔍 Setting this.approvalRequired = false due to missing Raiinmaker plugin`);
                    this.approvalRequired = false;
                } else {
                    // Skip Discord setup completely for Raiinmaker provider
                    elizaLogger.debug(`🔍 Skipping Discord setup for Raiinmaker provider`);
                    this.discordApprovalChannelId = "";
                    this.discordClientForApproval = null;
                }
            } else if (this.approvalProvider === "DISCORD") {
                elizaLogger.debug(`🔍 Entering Discord setup branch`);
                // Initialize Discord client
                const discordToken = this.runtime.getSetting("TWITTER_APPROVAL_DISCORD_BOT_TOKEN");
                const channelId = this.runtime.getSetting("TWITTER_APPROVAL_DISCORD_CHANNEL_ID");
                
                
                if (!discordToken || !channelId) {
                    elizaLogger.warn("Twitter approval is set to use Discord but credentials are missing");
                    elizaLogger.debug(`🔍 Setting this.approvalRequired = false due to missing Discord credentials`);
                    this.approvalRequired = false;
                } else {
                    elizaLogger.debug(`🔍 Setting Discord approval channel ID and initializing Discord client`);
                    this.discordApprovalChannelId = channelId;
                    elizaLogger.debug(`🔍 About to call setupDiscordClient()`);
                    this.setupDiscordClient();
                    elizaLogger.log("Discord approval client initialized");
                }
                
                // Skip Raiinmaker setup for Discord provider
                elizaLogger.debug(`🔍 Skipping Raiinmaker setup for Discord provider`);
                this.raiinmakerService = null;
            } else {
                elizaLogger.debug(`🔍 Unknown approval provider: "${this.approvalProvider}"`);
            }
        } else {
            elizaLogger.debug(`🔍 Twitter approval disabled by configuration`);
        }
        
        elizaLogger.debug(`🔍 TwitterPostClient constructor complete. Final approval provider: "${this.approvalProvider}", approval required: ${this.approvalRequired}`);
    }

    private setupDiscordClient() {
        try {
            // Check if required environment variables are set
            const token = this.runtime.getSetting("TWITTER_APPROVAL_DISCORD_BOT_TOKEN");
            this.discordApprovalChannelId = this.runtime.getSetting("TWITTER_APPROVAL_DISCORD_CHANNEL_ID");
            
            if (!token || !this.discordApprovalChannelId) {
                elizaLogger.error("Missing required Discord environment variables for Twitter approval");
                this.discordClientForApproval = null;
                return;
            }
            
            // Create Discord client
            this.discordClientForApproval = new Client({
                intents: [
                    GatewayIntentBits.Guilds,
                    GatewayIntentBits.GuildMessages,
                    GatewayIntentBits.MessageContent,
                    GatewayIntentBits.GuildMessageReactions,
                ],
                partials: [Partials.Channel, Partials.Message, Partials.Reaction],
            });
            
            this.discordClientForApproval.once(
                Events.ClientReady,
                (readyClient) => {
                    elizaLogger.log(
                        `Discord bot is ready as ${readyClient.user.tag}!`
                    );
                    
                    // Generate invite link with required permissions
                    const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;
                    // 274877991936 includes permissions for:
                    // - Send Messages
                    // - Read Messages/View Channels
                    // - Read Message History

                    elizaLogger.log(
                        `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`
                    );
                }
            );
            
            // Login to Discord with error handling
            this.discordClientForApproval.login(token).catch(error => {
                elizaLogger.error("Error logging in to Discord:", error);
                this.discordClientForApproval = null;
            });
        } catch (error) {
            elizaLogger.error("Exception setting up Discord client:", error);
            this.discordClientForApproval = null;
        }
    }

    /**
     * Sends a tweet for verification through the Raiinmaker system
     * 
     * @param tweetTextForPosting The tweet text to be verified
     * @param roomId The ID of the room associated with this tweet
     * @param rawTweetContent The raw content before processing
     * @returns The task ID of the verification task or null if creation failed
     */
    private async sendForRaiinmakerVerification(
        tweetTextForPosting: string,
        roomId: UUID,
        rawTweetContent: string
    ): Promise<string | null> {
        try {
            // First, explicitly check the provider and ensure Discord client is null for safety
            if (this.approvalProvider === "RAIINMAKER") {
                this.discordClientForApproval = null;
            }
            
            elizaLogger.log(`Sending tweet for Raiinmaker verification: "${tweetTextForPosting.substring(0, 50)}${tweetTextForPosting.length > 50 ? '...' : ''}"`);
            
            // Create a fallback room ID that's stable and reusable
            const verificationRoomId = stringToUuid("twitter_verification_room");
            
            // Try to use the provided room ID first
            try {
                await this.runtime.ensureRoomExists(roomId);
                await this.runtime.ensureParticipantInRoom(this.runtime.agentId, roomId);
            } catch (roomError) {
                elizaLogger.error("Failed to create original room for tweet verification:", roomError);
                
                // Use the fallback room ID instead
                try {
                    await this.runtime.ensureRoomExists(verificationRoomId);
                    await this.runtime.ensureParticipantInRoom(this.runtime.agentId, verificationRoomId);
                    // Update roomId to the fallback one that we know exists
                    roomId = verificationRoomId;
                } catch (fallbackError) {
                    elizaLogger.error("Failed to create fallback room for tweet verification:", fallbackError);
                    // If we can't create a room at all, we shouldn't proceed with verification
                    return null;
                }
            }
            
            // Create a verification task using the Raiinmaker plugin
            const verificationOptions = {
                subject: tweetTextForPosting,
                name: `Tweet Verification from @${this.twitterUsername}`,
                consensusVotes: 3,
                question: "Is this content appropriate for posting on Twitter?",
                roomId: roomId.toString() // Pass the roomId to the action
            };
            
            try {
                // Create a memory object for the action
                let verificationResult: any = null;
                const actionMemory: Memory = {
                    id: uuidv4() as `${string}-${string}-${string}-${string}-${string}`,
                    userId: this.runtime.agentId,
                    agentId: this.runtime.agentId,
                    roomId: roomId,
                    content: {
                        type: 'text',
                        text: `Verify this content: "${tweetTextForPosting}"`,  // Include in text with quotes
                        action: 'VERIFY_GENERATION_CONTENT',
                        options: {
                            content: tweetTextForPosting,  // Also include in options
                            name: `Tweet Verification from @${this.twitterUsername}`,
                            consensusVotes: 3,
                            question: "Is this content appropriate for posting on Twitter?",
                            roomId: roomId.toString()
                        }
                    }
                };

                // Process the action using runtime.processActions
                await this.runtime.processActions(
                    actionMemory,
                    [actionMemory],
                    undefined,
                    async (result) => {
                        if (result) {
                            verificationResult = result;
                        }
                        return [actionMemory];
                    }
                );
                
                // Extract taskId from verificationResult.text if it's not at the top level
                let taskId: string | null = null;
                
                if (verificationResult?.taskId) {
                    // If it's available at the top level, use that
                    taskId = verificationResult.taskId;
                } else if (verificationResult?.text) {
                    // Try to extract taskId from the text field using regex
                    const taskIdMatch = verificationResult.text.match(/Task ID: ([a-f0-9-]{36})/i);
                    if (taskIdMatch && taskIdMatch[1]) {
                        taskId = taskIdMatch[1];
                    }
                }
                
                if (!taskId) {
                    elizaLogger.error("Failed to create verification task: Invalid response from Raiinmaker plugin");
                    
                    // Fallback: If verification fails but we have configured the system to post directly,
                    // skip verification and post immediately
                    if (this.client.twitterConfig.POST_IMMEDIATELY) {
                        elizaLogger.warn("Verification failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                        
                        // Post the tweet directly
                        await this.postTweet(
                            this.runtime,
                            this.client,
                            tweetTextForPosting,
                            roomId,
                            rawTweetContent,
                            this.twitterUsername
                        );
                        
                        return "direct-posted"; // Special return value to indicate we posted directly
                    }
                    
                    return null;
                }
                
                elizaLogger.log(`Successfully created verification task with ID: ${taskId}`);
                
                // Store the pending tweet with the taskId
                const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweets`;
                const currentPendingTweets = (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) || [];
                
                // Add new pending tweet with Raiinmaker taskId
                currentPendingTweets.push({
                    tweetTextForPosting,
                    roomId,
                    rawTweetContent,
                    taskId: taskId,
                    timestamp: Date.now()
                });
                
                // Store updated array
                await this.runtime.cacheManager.set(pendingTweetsKey, currentPendingTweets);
                
                return taskId;
            } catch (actionError) {
                elizaLogger.error("Error executing VERIFY_GENERATION_CONTENT action:", actionError);
                
                // Fallback: If verification fails but we have configured the system to post directly,
                // skip verification and post immediately
                if (this.client.twitterConfig.POST_IMMEDIATELY) {
                    elizaLogger.warn("Verification failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                    
                    // Post the tweet directly
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername
                    );
                    
                    return "direct-posted"; // Special return value to indicate we posted directly
                }
                
                return null;
            }
        } catch (error) {
            elizaLogger.error("Error sending tweet for Raiinmaker verification:", error);
            
            // Fallback: If verification completely fails but we have configured the system to post directly,
            // skip verification and post immediately
            if (this.client.twitterConfig.POST_IMMEDIATELY) {
                elizaLogger.warn("Verification process failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                
                try {
                    // Post the tweet directly
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername
                    );
                    
                    return "direct-posted"; // Special return value to indicate we posted directly
                } catch (postError) {
                    elizaLogger.error("Failed to post tweet in fallback mode:", postError);
                    return null;
                }
            }
            
            return null;
        }
    }
    
    
    /**
     * Checks the verification status of a task in the Raiinmaker system
     * 
     * @param taskId The ID of the verification task
     * @returns The approval status of the task
     */
    private async checkRaiinmakerVerificationStatus(taskId: string): Promise<PendingTweetApprovalStatus> {
        try {
            if (this.approvalProvider !== "RAIINMAKER") {
                return "PENDING";
            }
            
            elizaLogger.log(`Checking verification status for task ID: ${taskId}`);
            
            try {
                let verificationStatus: any = null;
                
                const checkActionMemory: Memory = {
                    id: uuidv4() as `${string}-${string}-${string}-${string}-${string}`,
                    userId: this.runtime.agentId,
                    agentId: this.runtime.agentId,
                    roomId: stringToUuid("verification_status_check"),
                    content: {
                        type: 'text',
                        text: `Check verification status for task: "${taskId}"`,
                        action: 'CHECK_VERIFICATION_STATUS',
                        options: { taskId }
                    }
                };

                await this.runtime.processActions(
                    checkActionMemory,
                    [checkActionMemory],
                    undefined,
                    async (result) => {
                        verificationStatus = result;
                        return [checkActionMemory];
                    }
                );
                
                if (!verificationStatus) {
                    return "PENDING";
                }
                
                // Parse the task status
                const status = typeof verificationStatus.status === 'string' 
                    ? verificationStatus.status.toLowerCase() 
                    : null;
                    
                const answer = typeof verificationStatus.answer === 'string'
                    ? verificationStatus.answer.toLowerCase()
                    : null;
                
                // Check for completed and approved
                if (status === 'completed') {
                    if (answer === 'true' || answer === 'yes') {
                        return "APPROVED";
                    } else {
                        return "REJECTED";
                    }
                }
                
                return "PENDING";
                
            } catch (error: any) {
                if (error?.status === 404) {
                    return "REJECTED";
                }
                throw error;
            }
        } catch (error) {
            elizaLogger.error(`Error checking verification status for task ${taskId}:`, error);
            return "PENDING";
        }
    }

    /**
     * Sends a tweet for verification through the Discord approval system
     * 
     * @param tweetTextForPosting The tweet text to be verified
     * @param roomId The ID of the room associated with this tweet
     * @param rawTweetContent The raw content before processing
     * @returns The message ID or null if sending failed
     */
    private async sendForDiscordApproval(
        tweetTextForPosting: string,
        roomId: UUID,
        rawTweetContent: string
    ): Promise<string | null> {
        try {
            elizaLogger.log(`Sending tweet for Discord approval: "${tweetTextForPosting.substring(0, 50)}${tweetTextForPosting.length > 50 ? '...' : ''}"`);
            
            // Check if Discord client is initialized
            if (!this.discordClientForApproval || !this.discordApprovalChannelId) {
                elizaLogger.error("Discord client or channel ID not configured for approval");
                
                // If Discord approval fails but POST_IMMEDIATELY is enabled, post directly
                if (this.client.twitterConfig.POST_IMMEDIATELY) {
                    elizaLogger.warn("Discord approval failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                    
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername
                    );
                    
                    return "direct-posted";
                }
                
                return null;
            }
            
            // Create embed for Discord message
            const embed = {
                title: "New Tweet Pending Approval",
                description: tweetTextForPosting,
                fields: [
                    {
                        name: "Character",
                        value: this.client.profile.username,
                        inline: true,
                    },
                    {
                        name: "Length",
                        value: tweetTextForPosting.length.toString(),
                        inline: true,
                    },
                ],
                footer: {
                    text: "React with 👍 to approve or ❌ to reject. This will expire after 24 hours if no response received.",
                },
                timestamp: new Date().toISOString(),
                color: 0x1DA1F2, // Twitter blue color
            };
            
            // Fetch the channel
            try {
                const channel = await this.discordClientForApproval.channels.fetch(this.discordApprovalChannelId);
                
                if (!channel || !(channel instanceof TextChannel)) {
                    throw new Error(`Invalid Discord channel: ${this.discordApprovalChannelId}`);
                }
                
                // Send the approval message
                const message = await channel.send({ embeds: [embed] });
                
                // Add the approval reactions for easy clicking
                await message.react('👍');
                await message.react('❌');
                
                // Store the pending tweet
                const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweets`;
                const currentPendingTweets = (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) || [];
                
                // Add new pending tweet
                currentPendingTweets.push({
                    tweetTextForPosting,
                    roomId,
                    rawTweetContent,
                    taskId: message.id, // Use Discord message ID as task ID
                    timestamp: Date.now()
                });
                
                // Store updated array
                await this.runtime.cacheManager.set(pendingTweetsKey, currentPendingTweets);
                
                elizaLogger.success(`Successfully sent tweet for Discord approval with message ID: ${message.id}`);
                return message.id;
                
            } catch (error) {
                elizaLogger.error("Error sending Discord approval message:", error);
                
                // If Discord approval fails but POST_IMMEDIATELY is enabled, post directly
                if (this.client.twitterConfig.POST_IMMEDIATELY) {
                    elizaLogger.warn("Discord approval failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                    
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername
                    );
                    
                    return "direct-posted";
                }
                
                return null;
            }
        } catch (error) {
            elizaLogger.error("Error in Discord approval process:", error);
            
            // If verification completely fails but we have configured the system to post directly,
            // skip verification and post immediately
            if (this.client.twitterConfig.POST_IMMEDIATELY) {
                elizaLogger.warn("Discord approval process failed, but POST_IMMEDIATELY is enabled - posting tweet directly");
                
                try {
                    // Post the tweet directly
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername
                    );
                    
                    return "direct-posted"; // Special return value to indicate we posted directly
                } catch (postError) {
                    elizaLogger.error("Failed to post tweet in fallback mode:", postError);
                    return null;
                }
            }
            
            return null;
        }
    }

    /**
     * Starts the Twitter client and sets up all necessary loops and processes
     */
    async start() {
        try {
            // Force Discord client to null for RAIINMAKER provider
            if (this.approvalProvider?.toUpperCase() === "RAIINMAKER") {
                elizaLogger.debug(`🔍 Explicitly ensuring Discord client is null for RAIINMAKER provider during start()`);
                this.discordClientForApproval = null;
            }
            
            if (!this.client.profile) {
                await this.client.init();
            }

            const generateNewTweetLoop = async () => {
                const lastPost = await this.runtime.cacheManager.get<{
                    timestamp: number;
                }>("twitter/" + this.twitterUsername + "/lastPost");

                const lastPostTimestamp = lastPost?.timestamp ?? 0;
                const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;
                const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;
                const randomMinutes =
                    Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +
                    minMinutes;
                const delay = randomMinutes * 60 * 1000;

                if (Date.now() > lastPostTimestamp + delay) {
                    await this.generateNewTweet();
                }

                setTimeout(() => {
                    generateNewTweetLoop(); // Set up next iteration
                }, delay);

                elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);
            };

            const processActionsLoop = async () => {
                const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes

                while (!this.stopProcessingActions) {
                    try {
                        const results = await this.processTweetActions();
                        if (results) {
                            elizaLogger.log(`Processed ${results.length} tweets`);
                            elizaLogger.log(
                                `Next action processing scheduled in ${actionInterval} minutes`
                            );
                            // Wait for the full interval before next processing
                            await new Promise(
                                (resolve) =>
                                    setTimeout(resolve, actionInterval * 60 * 1000) // now in minutes
                            );
                        }
                    } catch (error) {
                        elizaLogger.error(
                            "Error in action processing loop:",
                            error
                        );
                        // Add exponential backoff on error
                        await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error
                    }
                }
            };

            if (this.client.twitterConfig.POST_IMMEDIATELY) {
                await this.generateNewTweet();
            }

            if (this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION) {
                generateNewTweetLoop();
                elizaLogger.log("Tweet generation loop started");
            }

            if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {
                processActionsLoop().catch((error) => {
                    elizaLogger.error(
                        "Fatal error in process actions loop:",
                        error
                    );
                });
            }

            // Start the pending tweet check loop if approval is required
            if (this.approvalRequired) {
                await this.startVerificationPolling();
            }
        } catch (error) {
            elizaLogger.error("Error starting Twitter client:", error);
        }
    }

    private runPendingTweetCheckLoop() {
        setInterval(async () => {
            await this.handlePendingTweet();
        }, this.approvalCheckInterval);
    }

    createTweetObject(
        tweetResult: any,
        client: any,
        twitterUsername: string
    ): Tweet {
        return {
            id: tweetResult.rest_id,
            name: client.profile.screenName,
            username: client.profile.username,
            text: tweetResult.legacy.full_text,
            conversationId: tweetResult.legacy.conversation_id_str,
            createdAt: tweetResult.legacy.created_at,
            timestamp: new Date(tweetResult.legacy.created_at).getTime(),
            userId: client.profile.id,
            inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,
            permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,
            hashtags: [],
            mentions: [],
            photos: [],
            thread: [],
            urls: [],
            videos: [],
        } as Tweet;
    }

    async processAndCacheTweet(
        runtime: IAgentRuntime,
        client: ClientBase,
        tweet: Tweet,
        roomId: UUID,
        rawTweetContent: string
    ) {
        // Cache the last post details
        await runtime.cacheManager.set(
            `twitter/${client.profile.username}/lastPost`,
            {
                id: tweet.id,
                timestamp: Date.now(),
            }
        );

        // Cache the tweet
        await client.cacheTweet(tweet);

        // Log the posted tweet
        elizaLogger.log(`Tweet posted:\n ${tweet.permanentUrl}`);

        // Ensure the room and participant exist
        await runtime.ensureRoomExists(roomId);
        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);

        // Create a memory for the tweet
        await runtime.messageManager.createMemory({
            id: stringToUuid(tweet.id + "-" + runtime.agentId),
            userId: runtime.agentId,
            agentId: runtime.agentId,
            roomId,
            content: {
                text: rawTweetContent.trim(),
                url: tweet.permanentUrl,
                source: "twitter",
            },
            embedding: getEmbeddingZeroVector(),
            createdAt: tweet.timestamp,
        });
    }

    async handleNoteTweet(
        client: ClientBase,
        content: string,
        tweetId?: string,
        mediaData?: MediaData[]
    ) {
        try {
            const noteTweetResult = await client.requestQueue.add(
                async () =>
                    await client.twitterClient.sendNoteTweet(
                        content,
                        tweetId,
                        mediaData
                    )
            );

            if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {
                // Note Tweet failed due to authorization. Falling back to standard Tweet.
                const truncateContent = truncateToCompleteSentence(
                    content,
                    this.client.twitterConfig.MAX_TWEET_LENGTH
                );
                return await this.sendStandardTweet(
                    client,
                    truncateContent,
                    tweetId
                );
            } else {
                return noteTweetResult.data.notetweet_create.tweet_results
                    .result;
            }
        } catch (error) {
            throw new Error(`Note Tweet failed: ${error}`);
        }
    }

    async sendStandardTweet(
        client: ClientBase,
        content: string,
        tweetId?: string,
        mediaData?: MediaData[]
    ) {
        try {
            const standardTweetResult = await client.requestQueue.add(
                async () =>
                    await client.twitterClient.sendTweet(
                        content,
                        tweetId,
                        mediaData
                    )
            );
            const body = await standardTweetResult.json();
            if (!body?.data?.create_tweet?.tweet_results?.result) {
                elizaLogger.error("Error sending tweet; Bad response:", body);
                return;
            }
            return body.data.create_tweet.tweet_results.result;
        } catch (error) {
            elizaLogger.error("Error sending standard Tweet:", error);
            throw error;
        }
    }

    async postTweet(
        runtime: IAgentRuntime,
        client: ClientBase,
        tweetTextForPosting: string,
        roomId: UUID,
        rawTweetContent: string,
        twitterUsername: string,
        mediaData?: MediaData[]
    ) {
        try {
            elizaLogger.log(`Posting new tweet:\n`);

            let result;

            if (tweetTextForPosting.length > DEFAULT_MAX_TWEET_LENGTH) {
                result = await this.handleNoteTweet(
                    client,
                    tweetTextForPosting,
                    undefined,
                    mediaData
                );
            } else {
                result = await this.sendStandardTweet(
                    client,
                    tweetTextForPosting,
                    undefined,
                    mediaData
                );
            }

            const tweet = this.createTweetObject(
                result,
                client,
                twitterUsername
            );

            await this.processAndCacheTweet(
                runtime,
                client,
                tweet,
                roomId,
                rawTweetContent
            );
        } catch (error) {
            elizaLogger.error("Error sending tweet:", error);
        }
    }

    /**
     * Sends a tweet for verification through the configured provider
     */
    private async sendForVerification(
        tweetTextForPosting: string,
        roomId: UUID,
        rawTweetContent: string
    ): Promise<string | null> {
        // Force provider to uppercase for consistent comparison
        const provider = this.approvalProvider.toUpperCase();
        
        // Add explicit safety measure - if we're using RAIINMAKER, nullify Discord
        if (provider === "RAIINMAKER") {
            this.discordClientForApproval = null;
            return this.sendForRaiinmakerVerification(tweetTextForPosting, roomId, rawTweetContent);
        } else if (provider === "DISCORD") {
            // Only attempt Discord if it's explicitly selected
            return this.sendForDiscordApproval(tweetTextForPosting, roomId, rawTweetContent);
        } else {
            // For any other provider, default to Raiinmaker for safety
            elizaLogger.warn(`Unknown provider "${this.approvalProvider}", defaulting to Raiinmaker`);
            this.discordClientForApproval = null;
            return this.sendForRaiinmakerVerification(tweetTextForPosting, roomId, rawTweetContent);
        }
    }

    /**
     * Generates a new tweet, sends it for verification if required, or posts it directly
     */
    async generateNewTweet() {
        elizaLogger.log("Generating new tweet");

        try {
            const roomId = stringToUuid(
                "twitter_generate_room-" + this.client.profile.username
            );
            await this.runtime.ensureUserExists(
                this.runtime.agentId,
                this.client.profile.username,
                this.runtime.character.name,
                "twitter"
            );

            const topics = this.runtime.character.topics.join(", ");
            const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;
            const state = await this.runtime.composeState(
                {
                    userId: this.runtime.agentId,
                    roomId: roomId,
                    agentId: this.runtime.agentId,
                    content: {
                        text: topics || "",
                        action: "TWEET",
                    },
                },
                {
                    twitterUserName: this.client.profile.username,
                    maxTweetLength,
                }
            );

            const context = composeContext({
                state,
                template:
                    this.runtime.character.templates?.twitterPostTemplate ||
                    twitterPostTemplate,
            });

            const response = await generateText({
                runtime: this.runtime,
                context,
                modelClass: ModelClass.SMALL,
            });

            const rawTweetContent = cleanJsonResponse(response);

            // First attempt to clean content
            let tweetTextForPosting = null;
            let mediaData = null;

            // Try parsing as JSON first
            const parsedResponse = parseJSONObjectFromText(rawTweetContent);
            if (parsedResponse?.text) {
                tweetTextForPosting = parsedResponse.text;
            } else {
                // If not JSON, use the raw text directly
                tweetTextForPosting = rawTweetContent.trim();
            }

            if (
                parsedResponse?.attachments &&
                parsedResponse?.attachments.length > 0
            ) {
                mediaData = await fetchMediaData(parsedResponse.attachments);
            }

            // Try extracting text attribute
            if (!tweetTextForPosting) {
                const parsingText = extractAttributes(rawTweetContent, [
                    "text",
                ]).text;
                if (parsingText) {
                    tweetTextForPosting = truncateToCompleteSentence(
                        extractAttributes(rawTweetContent, ["text"]).text,
                        this.client.twitterConfig.MAX_TWEET_LENGTH
                    );
                }
            }

            // Use the raw text
            if (!tweetTextForPosting) {
                tweetTextForPosting = rawTweetContent;
            }

            // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.
            if (maxTweetLength) {
                tweetTextForPosting = truncateToCompleteSentence(
                    tweetTextForPosting,
                    maxTweetLength
                );
            }

            const removeQuotes = (str: string) =>
                str.replace(/^['"](.*)['"]$/, "$1");

            const fixNewLines = (str: string) => str.replaceAll(/\\n/g, "\n\n"); //ensures double spaces

            // Final cleaning
            tweetTextForPosting = removeQuotes(
                fixNewLines(tweetTextForPosting)
            );

            if (this.isDryRun) {
                elizaLogger.info(
                    `Dry run: would have posted tweet: ${tweetTextForPosting}`
                );
                return;
            }

            try {
                if (this.approvalRequired) {
                    // Send for verification using the configured provider
                    elizaLogger.log(`Sending Tweet for ${this.approvalProvider} verification:\n ${tweetTextForPosting}`);
                    
                    const taskId = await this.sendForVerification(
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent
                    );
                    
                    if (taskId === "direct-posted") {
                        elizaLogger.log("Tweet was posted directly due to verification fallback");
                    } else if (taskId) {
                        elizaLogger.log(`Tweet sent for verification with task ID: ${taskId}`);
                    } else {
                        elizaLogger.error("Failed to send tweet for verification");
                    }
                } else {
                    elizaLogger.log(
                        `Posting new tweet directly (no approval required):\n ${tweetTextForPosting}`
                    );
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        tweetTextForPosting,
                        roomId,
                        rawTweetContent,
                        this.twitterUsername,
                        mediaData
                    );
                }
            } catch (error) {
                elizaLogger.error("Error sending tweet:", error);
            }
        } catch (error) {
            elizaLogger.error("Error generating new tweet:", error);
        }
    }

    private async generateTweetContent(
        tweetState: any,
        options?: {
            template?: TemplateType;
            context?: string;
        }
    ): Promise<string> {
        const context = composeContext({
            state: tweetState,
            template:
                options?.template ||
                this.runtime.character.templates?.twitterPostTemplate ||
                twitterPostTemplate,
        });

        const response = await generateText({
            runtime: this.runtime,
            context: options?.context || context,
            modelClass: ModelClass.SMALL,
        });

        elizaLogger.log("generate tweet content response:\n" + response);

        // First clean up any markdown and newlines
        const cleanedResponse = cleanJsonResponse(response);

        // Try to parse as JSON first
        const jsonResponse = parseJSONObjectFromText(cleanedResponse);
        if (jsonResponse.text) {
            const truncateContent = truncateToCompleteSentence(
                jsonResponse.text,
                this.client.twitterConfig.MAX_TWEET_LENGTH
            );
            return truncateContent;
        }
        if (typeof jsonResponse === "object") {
            const possibleContent =
                jsonResponse.content ||
                jsonResponse.message ||
                jsonResponse.response;
            if (possibleContent) {
                const truncateContent = truncateToCompleteSentence(
                    possibleContent,
                    this.client.twitterConfig.MAX_TWEET_LENGTH
                );
                return truncateContent;
            }
        }

        let truncateContent = null;
        // Try extracting text attribute
        const parsingText = extractAttributes(cleanedResponse, ["text"]).text;
        if (parsingText) {
            truncateContent = truncateToCompleteSentence(
                parsingText,
                this.client.twitterConfig.MAX_TWEET_LENGTH
            );
        }

        if (!truncateContent) {
            // If not JSON or no valid content found, clean the raw text
            truncateContent = truncateToCompleteSentence(
                cleanedResponse,
                this.client.twitterConfig.MAX_TWEET_LENGTH
            );
        }

        return truncateContent;
    }


    /**
     * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,
     * only simulates and logs actions without making API calls.
     */
    private async processTweetActions() {
        if (this.isProcessing) {
            elizaLogger.log("Already processing tweet actions, skipping");
            return null;
        }

        try {
            this.isProcessing = true;
            this.lastProcessTime = Date.now();

            elizaLogger.log("Processing tweet actions");

            await this.runtime.ensureUserExists(
                this.runtime.agentId,
                this.twitterUsername,
                this.runtime.character.name,
                "twitter"
            );

            const timelines = await this.client.fetchTimelineForActions(
                MAX_TIMELINES_TO_FETCH
            );
            const maxActionsProcessing =
                this.client.twitterConfig.MAX_ACTIONS_PROCESSING;
            const processedTimelines = [];

            for (const tweet of timelines) {
                try {
                    // Skip if we've already processed this tweet
                    const memory =
                        await this.runtime.messageManager.getMemoryById(
                            stringToUuid(tweet.id + "-" + this.runtime.agentId)
                        );
                    if (memory) {
                        elizaLogger.log(
                            `Already processed tweet ID: ${tweet.id}`
                        );
                        continue;
                    }

                    const roomId = stringToUuid(
                        tweet.conversationId + "-" + this.runtime.agentId
                    );

                    const tweetState = await this.runtime.composeState(
                        {
                            userId: this.runtime.agentId,
                            roomId,
                            agentId: this.runtime.agentId,
                            content: { text: "", action: "" },
                        },
                        {
                            twitterUserName: this.twitterUsername,
                            currentTweet: `ID: ${tweet.id}\nFrom: ${tweet.name} (@${tweet.username})\nText: ${tweet.text}`,
                        }
                    );

                    const actionContext = composeContext({
                        state: tweetState,
                        template:
                            this.runtime.character.templates
                                ?.twitterActionTemplate ||
                            twitterActionTemplate,
                    });

                    const actionResponse = await generateTweetActions({
                        runtime: this.runtime,
                        context: actionContext,
                        modelClass: ModelClass.SMALL,
                    });

                    if (!actionResponse) {
                        elizaLogger.log(
                            `No valid actions generated for tweet ${tweet.id}`
                        );
                        continue;
                    }
                    processedTimelines.push({
                        tweet: tweet,
                        actionResponse: actionResponse,
                        tweetState: tweetState,
                        roomId: roomId,
                    });
                } catch (error) {
                    elizaLogger.error(
                        `Error processing tweet ${tweet.id}:`,
                        error
                    );
                    continue;
                }
            }

            const sortProcessedTimeline = (arr: typeof processedTimelines) => {
                return arr.sort((a, b) => {
                    // Count the number of true values in the actionResponse object
                    const countTrue = (obj: typeof a.actionResponse) =>
                        Object.values(obj).filter(Boolean).length;

                    const countA = countTrue(a.actionResponse);
                    const countB = countTrue(b.actionResponse);

                    // Primary sort by number of true values
                    if (countA !== countB) {
                        return countB - countA;
                    }

                    // Secondary sort by the "like" property
                    if (a.actionResponse.like !== b.actionResponse.like) {
                        return a.actionResponse.like ? -1 : 1;
                    }

                    // Tertiary sort keeps the remaining objects with equal weight
                    return 0;
                });
            };
            // Sort the timeline based on the action decision score,
            // then slice the results according to the environment variable to limit the number of actions per cycle.
            const sortedTimelines = sortProcessedTimeline(
                processedTimelines
            ).slice(0, maxActionsProcessing);

            return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion
        } catch (error) {
            elizaLogger.error("Error in processTweetActions:", error);
            throw error;
        } finally {
            this.isProcessing = false;
        }
    }

    /**
     * Processes a list of timelines by executing the corresponding tweet actions.
     * Each timeline includes the tweet, action response, tweet state, and room context.
     * Results are returned for tracking completed actions.
     *
     * @param timelines - Array of objects containing tweet details, action responses, and state information.
     * @returns A promise that resolves to an array of results with details of executed actions.
     */
    private async processTimelineActions(
        timelines: {
            tweet: Tweet;
            actionResponse: ActionResponse;
            tweetState: State;
            roomId: UUID;
        }[]
    ): Promise<
        {
            tweetId: string;
            actionResponse: ActionResponse;
            executedActions: string[];
        }[]
    > {
        const results = [];
        for (const timeline of timelines) {
            const { actionResponse, tweetState, roomId, tweet } = timeline;
            try {
                const executedActions: string[] = [];
                // Execute actions
                if (actionResponse.like) {
                    if (this.isDryRun) {
                        elizaLogger.info(
                            `Dry run: would have liked tweet ${tweet.id}`
                        );
                        executedActions.push("like (dry run)");
                    } else {
                        try {
                            await this.client.twitterClient.likeTweet(tweet.id);
                            executedActions.push("like");
                            elizaLogger.log(`Liked tweet ${tweet.id}`);
                        } catch (error) {
                            elizaLogger.error(
                                `Error liking tweet ${tweet.id}:`,
                                error
                            );
                        }
                    }
                }

                if (actionResponse.retweet) {
                    if (this.isDryRun) {
                        elizaLogger.info(
                            `Dry run: would have retweeted tweet ${tweet.id}`
                        );
                        executedActions.push("retweet (dry run)");
                    } else {
                        try {
                            await this.client.twitterClient.retweet(tweet.id);
                            executedActions.push("retweet");
                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);
                        } catch (error) {
                            elizaLogger.error(
                                `Error retweeting tweet ${tweet.id}:`,
                                error
                            );
                        }
                    }
                }

                if (actionResponse.quote) {
                    try {
                        // Build conversation thread for context
                        const thread = await buildConversationThread(
                            tweet,
                            this.client
                        );
                        const formattedConversation = thread
                            .map(
                                (t) =>
                                    `@${t.username} (${new Date(
                                        t.timestamp * 1000
                                    ).toLocaleString()}): ${t.text}`
                            )
                            .join("\n\n");

                        // Generate image descriptions if present
                        const imageDescriptions = [];
                        if (tweet.photos?.length > 0) {
                            elizaLogger.log(
                                "Processing images in tweet for context"
                            );
                            for (const photo of tweet.photos) {
                                const description = await this.runtime
                                    .getService<IImageDescriptionService>(
                                        ServiceType.IMAGE_DESCRIPTION
                                    )
                                    .describeImage(photo.url);
                                imageDescriptions.push(description);
                            }
                        }

                        // Handle quoted tweet if present
                        let quotedContent = "";
                        if (tweet.quotedStatusId) {
                            try {
                                const quotedTweet =
                                    await this.client.twitterClient.getTweet(
                                        tweet.quotedStatusId
                                    );
                                if (quotedTweet) {
                                    quotedContent = `\nQuoted Tweet from @${quotedTweet.username}:\n${quotedTweet.text}`;
                                }
                            } catch (error) {
                                elizaLogger.error(
                                    "Error fetching quoted tweet:",
                                    error
                                );
                            }
                        }

                        // Compose rich state with all context
                        const enrichedState = await this.runtime.composeState(
                            {
                                userId: this.runtime.agentId,
                                roomId: stringToUuid(
                                    tweet.conversationId +
                                        "-" +
                                        this.runtime.agentId
                                ),
                                agentId: this.runtime.agentId,
                                content: {
                                    text: tweet.text,
                                    action: "QUOTE",
                                },
                            },
                            {
                                twitterUserName: this.twitterUsername,
                                currentPost: `From @${tweet.username}: ${tweet.text}`,
                                formattedConversation,
                                imageContext:
                                    imageDescriptions.length > 0
                                        ? `\nImages in Tweet:\n${imageDescriptions
                                              .map(
                                                  (desc, i) =>
                                                      `Image ${i + 1}: ${desc}`
                                              )
                                              .join("\n")}`
                                        : "",
                                quotedContent,
                            }
                        );

                        const quoteContent = await this.generateTweetContent(
                            enrichedState,
                            {
                                template:
                                    this.runtime.character.templates
                                        ?.twitterMessageHandlerTemplate ||
                                    twitterMessageHandlerTemplate,
                            }
                        );

                        if (!quoteContent) {
                            elizaLogger.error(
                                "Failed to generate valid quote tweet content"
                            );
                            return;
                        }

                        elizaLogger.log(
                            "Generated quote tweet content:",
                            quoteContent
                        );
                        // Check for dry run mode
                        if (this.isDryRun) {
                            elizaLogger.info(
                                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: "${quoteContent}".`
                            );
                            executedActions.push("quote (dry run)");
                        } else {
                            // Send the tweet through request queue
                            const result = await this.client.requestQueue.add(
                                async () =>
                                    await this.client.twitterClient.sendQuoteTweet(
                                        quoteContent,
                                        tweet.id
                                    )
                            );

                            const body = await result.json();

                            if (
                                body?.data?.create_tweet?.tweet_results?.result
                            ) {
                                elizaLogger.log(
                                    "Successfully posted quote tweet"
                                );
                                executedActions.push("quote");

                                // Cache generation context for debugging
                                await this.runtime.cacheManager.set(
                                    `twitter/quote_generation_${tweet.id}.txt`,
                                    `Context:\n${enrichedState}\n\nGenerated Quote:\n${quoteContent}`
                                );
                            } else {
                                elizaLogger.error(
                                    "Quote tweet creation failed:",
                                    body
                                );
                            }
                        }
                    } catch (error) {
                        elizaLogger.error(
                            "Error in quote tweet generation:",
                            error
                        );
                    }
                }

                if (actionResponse.reply) {
                    try {
                        await this.handleTextOnlyReply(
                            tweet,
                            tweetState,
                            executedActions
                        );
                    } catch (error) {
                        elizaLogger.error(
                            `Error replying to tweet ${tweet.id}:`,
                            error
                        );
                    }
                }

                // Add these checks before creating memory
                await this.runtime.ensureRoomExists(roomId);
                await this.runtime.ensureUserExists(
                    stringToUuid(tweet.userId),
                    tweet.username,
                    tweet.name,
                    "twitter"
                );
                await this.runtime.ensureParticipantInRoom(
                    this.runtime.agentId,
                    roomId
                );

                if (!this.isDryRun) {
                    // Then create the memory
                    await this.runtime.messageManager.createMemory({
                        id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
                        userId: stringToUuid(tweet.userId),
                        content: {
                            text: tweet.text,
                            url: tweet.permanentUrl,
                            source: "twitter",
                            action: executedActions.join(","),
                        },
                        agentId: this.runtime.agentId,
                        roomId,
                        embedding: getEmbeddingZeroVector(),
                        createdAt: tweet.timestamp * 1000,
                    });
                }

                results.push({
                    tweetId: tweet.id,
                    actionResponse: actionResponse,
                    executedActions,
                });
            } catch (error) {
                elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);
                continue;
            }
        }

        return results;
    }

    /**
     * Handles text-only replies to tweets. If isDryRun is true, only logs what would
     * have been replied without making API calls.
     */
    private async handleTextOnlyReply(
        tweet: Tweet,
        tweetState: any,
        executedActions: string[]
    ) {
        try {
            // Build conversation thread for context
            const thread = await buildConversationThread(tweet, this.client);
            const formattedConversation = thread
                .map(
                    (t) =>
                        `@${t.username} (${new Date(
                            t.timestamp * 1000
                        ).toLocaleString()}): ${t.text}`
                )
                .join("\n\n");

            // Generate image descriptions if present
            const imageDescriptions = [];
            if (tweet.photos?.length > 0) {
                elizaLogger.log("Processing images in tweet for context");
                for (const photo of tweet.photos) {
                    const description = await this.runtime
                        .getService<IImageDescriptionService>(
                            ServiceType.IMAGE_DESCRIPTION
                        )
                        .describeImage(photo.url);
                    imageDescriptions.push(description);
                }
            }

            // Handle quoted tweet if present
            let quotedContent = "";
            if (tweet.quotedStatusId) {
                try {
                    const quotedTweet =
                        await this.client.twitterClient.getTweet(
                            tweet.quotedStatusId
                        );
                    if (quotedTweet) {
                        quotedContent = `\nQuoted Tweet from @${quotedTweet.username}:\n${quotedTweet.text}`;
                    }
                } catch (error) {
                    elizaLogger.error("Error fetching quoted tweet:", error);
                }
            }

            // Compose rich state with all context
            const enrichedState = await this.runtime.composeState(
                {
                    userId: this.runtime.agentId,
                    roomId: stringToUuid(
                        tweet.conversationId + "-" + this.runtime.agentId
                    ),
                    agentId: this.runtime.agentId,
                    content: { text: tweet.text, action: "" },
                },
                {
                    twitterUserName: this.twitterUsername,
                    currentPost: `From @${tweet.username}: ${tweet.text}`,
                    formattedConversation,
                    imageContext:
                        imageDescriptions.length > 0
                            ? `\nImages in Tweet:\n${imageDescriptions
                                  .map((desc, i) => `Image ${i + 1}: ${desc}`)
                                  .join("\n")}`
                            : "",
                    quotedContent,
                }
            );

            // Generate and clean the reply content
            const replyText = await this.generateTweetContent(enrichedState, {
                template:
                    this.runtime.character.templates
                        ?.twitterMessageHandlerTemplate ||
                    twitterMessageHandlerTemplate,
            });

            if (!replyText) {
                elizaLogger.error("Failed to generate valid reply content");
                return;
            }

            if (this.isDryRun) {
                elizaLogger.info(
                    `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`
                );
                executedActions.push("reply (dry run)");
                return;
            }

            let result;

            if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {
                result = await this.handleNoteTweet(
                    this.client,
                    replyText,
                    tweet.id
                );
            } else {
                result = await this.sendStandardTweet(
                    this.client,
                    replyText,
                    tweet.id
                );
            }

            if (result) {
                elizaLogger.log("Successfully posted reply tweet");
                executedActions.push("reply");

                // Cache generation context for debugging
                await this.runtime.cacheManager.set(
                    `twitter/reply_generation_${tweet.id}.txt`,
                    `Context:\n${enrichedState}\n\nGenerated Reply:\n${replyText}`
                );
            } else {
                elizaLogger.error("Tweet reply creation failed");
            }
        } catch (error) {
            elizaLogger.error("Error in handleTextOnlyReply:", error);
        }
    }

    /**
     * Stops all client processes
     */
    async stop() {
        this.stopProcessingActions = true;
        
        // Disconnect Discord client if it was initialized
        if (this.discordClientForApproval) {
            elizaLogger.log("Disconnecting Discord client");
            this.discordClientForApproval.destroy();
        }
        
        elizaLogger.log("Twitter post client stopped");
    }

    private async checkVerificationStatus(taskId: string): Promise<PendingTweetApprovalStatus> {
        if (this.approvalProvider === "DISCORD") {
            return this.checkApprovalStatus(taskId);
        } else if (this.approvalProvider === "RAIINMAKER") {
            return this.checkRaiinmakerVerificationStatus(taskId);
        } else {
            elizaLogger.warn(`Unknown provider "${this.approvalProvider}", defaulting to PENDING status`);
            return "PENDING";
        }
    }

    private async checkApprovalStatus(
        discordMessageId: string
    ): Promise<PendingTweetApprovalStatus> {
        try {
            // Guard to prevent Discord checks when not using Discord provider
            if (this.approvalProvider !== "DISCORD") {
                return "PENDING";
            }
            
            // Fetch message and its replies from Discord
            if (!this.discordClientForApproval) {
                elizaLogger.error("Discord client not initialized for approval check");
                return "PENDING";
            }
            
            const channel = await this.discordClientForApproval.channels.fetch(
                this.discordApprovalChannelId
            );

            if (!(channel instanceof TextChannel)) {
                elizaLogger.error("Invalid approval channel");
                return "PENDING";
            }

            // Fetch the original message and its replies
            const message = await channel.messages.fetch(discordMessageId);

            // Look for thumbs up reaction ('👍')
            const thumbsUpReaction = message.reactions.cache.find(
                (reaction) => reaction.emoji.name === "👍"
            );

            // Look for reject reaction ('❌')
            const rejectReaction = message.reactions.cache.find(
                (reaction) => reaction.emoji.name === "❌"
            );

            // Check if the reaction exists and has reactions
            if (rejectReaction) {
                const reactionCount = rejectReaction.count;
                if (reactionCount > 1) { // More than just the bot's reaction
                    elizaLogger.log(`Tweet rejected via Discord reaction`);
                    return "REJECTED";
                }
            }

            // Check thumbs up for approval
            if (thumbsUpReaction) {
                const reactionCount = thumbsUpReaction.count;
                if (reactionCount > 1) { // More than just the bot's reaction
                    elizaLogger.log(`Tweet approved via Discord reaction`);
                    return "APPROVED";
                }
            }

            // If we reach here, no valid approval or rejection found
            return "PENDING";
        } catch (error) {
            elizaLogger.error(`Error checking approval status: ${error}`);
            return "PENDING";
        }
    }

    /**
     * Cleans up a pending tweet from the cache
     * 
     * @param taskId The ID of the verification task to clean up
     */
    private async cleanupPendingTweet(taskId: string) {
        try {
            const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweets`;
            const currentPendingTweets = (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) || [];
    
            // Remove the specific tweet
            const updatedPendingTweets = currentPendingTweets.filter(
                (tweet) => tweet.taskId !== taskId
            );
    
            if (updatedPendingTweets.length === 0) {
                await this.runtime.cacheManager.delete(pendingTweetsKey);
                elizaLogger.debug("All pending tweets processed, clearing cache");
            } else {
                await this.runtime.cacheManager.set(pendingTweetsKey, updatedPendingTweets);
                elizaLogger.debug(`Updated pending tweets cache, ${updatedPendingTweets.length} tweets remaining`);
            }
            
            // Create a consistent room ID for tweet verification tracking
            const roomId = stringToUuid("twitter_verification_room");
            
            // Ensure the room exists before creating a memory
            try {
                await this.runtime.ensureRoomExists(roomId);
                await this.runtime.ensureParticipantInRoom(this.runtime.agentId, roomId);
                
                // Add a memory to track the resolution of this verification
                await this.runtime.messageManager.createMemory({
                    id: stringToUuid(`tweet-verification-cleanup-${Date.now()}`),
                    userId: this.runtime.agentId,
                    agentId: this.runtime.agentId,
                    content: {
                        text: `Verification task ${taskId} processed and removed from pending queue`,
                        metadata: {
                            taskType: "tweetVerificationCleanup",
                            taskId: taskId,
                            timestamp: Date.now()
                        }
                    },
                    roomId: roomId,
                    createdAt: Date.now()
                });
            } catch (roomError) {
                // If we can't create the room or memory, just log it but don't fail
                elizaLogger.error("Error creating verification tracking memory:", roomError);
                // Don't rethrow - we should still consider the task cleaned up even if we can't save a memory
            }
        } catch (error) {
            // Log the error but don't let it crash the process
            elizaLogger.error("Error cleaning up pending tweet:", error);
        }
    }

     /**
     * Handles pending tweets by checking their verification status and processing them accordingly
     */
     private async handlePendingTweet() {
        elizaLogger.log(`Checking pending tweets using ${this.approvalProvider} verification...`);
        elizaLogger.debug(`🔍 handlePendingTweet called with approval provider: "${this.approvalProvider}"`);
        
        // Additional safeguard to prevent Discord initialization for RAIINMAKER
        if (this.approvalProvider.toUpperCase() === "RAIINMAKER") {
            elizaLogger.debug(`🔍 Explicitly ensuring Discord client is null for RAIINMAKER provider`);
            this.discordClientForApproval = null;
        }
        
        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweets`;
        const pendingTweets = (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) || [];
    
        if (pendingTweets.length === 0) {
            elizaLogger.log("No pending tweets to check");
            return;
        }
    
        elizaLogger.log(`Found ${pendingTweets.length} pending tweets to check`);
        elizaLogger.debug(`🔍 Processing ${pendingTweets.length} pending tweets`);
        
        for (const pendingTweet of pendingTweets) {
            elizaLogger.log(`Processing pending tweet with taskId: ${pendingTweet.taskId}`);
            elizaLogger.debug(`🔍 Checking tweet with taskId: ${pendingTweet.taskId}`);
            
            // Check if tweet is older than 24 hours
            const isExpired = Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;
    
            if (isExpired) {
                elizaLogger.warn(`Pending tweet with task ID ${pendingTweet.taskId} expired after 24 hours`);
                elizaLogger.debug(`🔍 Tweet expired, cleaning up`);
                await this.cleanupPendingTweet(pendingTweet.taskId);
                continue;
            }
    
            // Check approval status using the configured provider
            elizaLogger.log(`Checking verification status for task: ${pendingTweet.taskId}`);
            elizaLogger.debug(`🔍 About to call checkVerificationStatus for task: ${pendingTweet.taskId}`);
            const approvalStatus = await this.checkVerificationStatus(pendingTweet.taskId);
            elizaLogger.log(`Approval status for task ${pendingTweet.taskId}: ${approvalStatus}`);
            elizaLogger.debug(`🔍 Received approval status: ${approvalStatus}`);
    
            if (approvalStatus === "APPROVED") {
                elizaLogger.log(`Tweet with task ID ${pendingTweet.taskId} approved, posting now...`);
                elizaLogger.debug(`🔍 Tweet approved, proceeding to post`);
                
                try {
                    await this.postTweet(
                        this.runtime,
                        this.client,
                        pendingTweet.tweetTextForPosting,
                        pendingTweet.roomId,
                        pendingTweet.rawTweetContent,
                        this.twitterUsername
                    );
                    
                    elizaLogger.success(`Successfully posted verified tweet`);
                } catch (error) {
                    elizaLogger.error(`Error posting approved tweet:`, error);
                }
    
                await this.cleanupPendingTweet(pendingTweet.taskId);
                
            } else if (approvalStatus === "REJECTED") {
                elizaLogger.warn(`Tweet with task ID ${pendingTweet.taskId} rejected by ${this.approvalProvider} verification`);
                elizaLogger.debug(`🔍 Tweet rejected, cleaning up`);
                await this.cleanupPendingTweet(pendingTweet.taskId);
            } else {
                elizaLogger.log(`Tweet with task ID ${pendingTweet.taskId} still pending verification`);
                elizaLogger.debug(`🔍 Tweet still pending verification`);
            }
        }
    }
    
    private async startVerificationPolling() {
        try {
            // Set up the regular interval check
            setInterval(async () => {
                try {
                    // Extra safeguard to ensure Discord is null for RAIINMAKER on each check
                    if (this.approvalProvider.toUpperCase() === "RAIINMAKER") {
                        this.discordClientForApproval = null;
                    }
                    
                    await this.handlePendingTweet();
                } catch (error) {
                    elizaLogger.error("Error in tweet verification check loop:", error);
                }
            }, 5 * 60 * 1000); // Check every 5 minutes
            
            elizaLogger.log(`Started ${this.approvalProvider} verification check loop`);
        } catch (error) {
            elizaLogger.error("Error starting verification polling:", error);
        }
    }
}

```